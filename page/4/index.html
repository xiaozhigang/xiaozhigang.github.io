<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" integrity="sha256-wiz7ZSCn/btzhjKDQBms9Hx4sSeUYsDrTLg7roPstac=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.19.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="最后不知天在水，满船清梦压星河。">
<meta property="og:type" content="website">
<meta property="og:title" content="xiaozhigang">
<meta property="og:url" content="http://example.com/page/4/index.html">
<meta property="og:site_name" content="xiaozhigang">
<meta property="og:description" content="最后不知天在水，满船清梦压星河。">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="xiaozhigang">
<meta property="article:tag" content="java,中间件，后端，大数据，ai">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/page/4/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/4/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>xiaozhigang</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">xiaozhigang</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">长风破浪会有时，直挂云帆济沧海。</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">xiaozhigang</p>
  <div class="site-description" itemprop="description">最后不知天在水，满船清梦压星河。</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">42</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">32</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/10/Spring-IoC-%E7%9A%84%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="xiaozhigang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xiaozhigang">
      <meta itemprop="description" content="最后不知天在水，满船清梦压星河。">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | xiaozhigang">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/10/10/Spring-IoC-%E7%9A%84%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0/" class="post-title-link" itemprop="url">Spring IoC 的简单实现</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-10-10 18:44:13" itemprop="dateCreated datePublished" datetime="2022-10-10T18:44:13+08:00">2022-10-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JAVA/" itemprop="url" rel="index"><span itemprop="name">JAVA</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h3><p>IoC是指控制反转，是指有容器来控制对象的生命周期和对象之间的关系。简单来说就是之前使用对象首先需要new一个对象，而现在直接从容器中取就可以了。这就像有小农经济转变到商品经济。</p>
<p>小农经济：自给自足，什么东西都需要自己动手也就类似于对象需要自己new。</p>
<p>商品经济：需要啥去商店买就行，这里的商店就相当于容器，商品就相当于对象，生成商品的工厂就相当于对象工厂等。</p>
<p><img src="/../images/spring-ioc/image-20240401193113474.png"></p>
<h3 id="Spring-IOC-的简单实现"><a href="#Spring-IOC-的简单实现" class="headerlink" title="Spring IOC 的简单实现"></a>Spring IOC 的简单实现</h3><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>1、首先我们得有一个容器，这个容器负责保存和生成bean，这也就是对象工厂BeanFactory 。</p>
<p>2、其次，得有一个bean注册器，这负责bean的注册和真正生成。</p>
<p>3、然后，还得有一个资源加载器，用来加载bean的定义</p>
<p>4、最后，得有一个bean的定义模型和配置文件。</p>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>分析为倒叙分析，实现就得看正序实现了，不然依赖就颠倒了。</p>
<h5 id="1、配置文件和bean模型"><a href="#1、配置文件和bean模型" class="headerlink" title="1、配置文件和bean模型"></a>1、配置文件和bean模型</h5><p>先准备一个示例的bean</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class BeanExample &#123;</span><br><span class="line">    public void print(String string)&#123;</span><br><span class="line">        System.out.println(&quot;test out: &quot; + string);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置文件，偷懒使用一个&lt;key,value&gt;键值对代替</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">beanExample:com.shopmall.springIoc.BeanExample</span><br></pre></td></tr></table></figure>

<p>bean模型定义</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Getter</span><br><span class="line">@Setter</span><br><span class="line">public class BeanDefinition &#123;</span><br><span class="line">    private String beanName;</span><br><span class="line"></span><br><span class="line">    private Class beanClass;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="2、资源加载器"><a href="#2、资源加载器" class="headerlink" title="2、资源加载器"></a>2、资源加载器</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class ResourceLoader &#123;</span><br><span class="line">    public static Map&lt;String, BeanDefinition&gt; getResource() &#123;</span><br><span class="line">        Map&lt;String, BeanDefinition&gt; beanDefinitionMap = new HashMap&lt;&gt;();</span><br><span class="line">        Properties properties = new Properties();</span><br><span class="line">        try &#123;</span><br><span class="line">            InputStream inputStream = ResourceLoader.class.getResourceAsStream(&quot;/beans.properties&quot;);</span><br><span class="line">            properties.load(inputStream);</span><br><span class="line">            for (String key : properties.stringPropertyNames()) &#123;</span><br><span class="line">                String className = properties.getProperty(key);</span><br><span class="line">                BeanDefinition beanDefinition = new BeanDefinition();</span><br><span class="line">                beanDefinition.setBeanName(key);</span><br><span class="line">                Class clazz = Class.forName(className);</span><br><span class="line">                beanDefinition.setBeanClass(clazz);</span><br><span class="line">                beanDefinitionMap.put(key, beanDefinition);</span><br><span class="line">            &#125;</span><br><span class="line">            inputStream.close();</span><br><span class="line">        &#125; catch (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return beanDefinitionMap;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3、对象注册器"><a href="#3、对象注册器" class="headerlink" title="3、对象注册器"></a>3、对象注册器</h5><p>简化过程，都用单例了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class BeanRegister &#123;</span><br><span class="line"></span><br><span class="line">    //单例Bean缓存</span><br><span class="line">    private final Map&lt;String, Object&gt; singletonBeanMap = new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取单例Bean</span><br><span class="line">     *</span><br><span class="line">     * @param beanName bean名称</span><br><span class="line">     * @return Object 单例Bean</span><br><span class="line">     */</span><br><span class="line">    public Object getSingletonBean(String beanName) &#123;</span><br><span class="line">        return singletonBeanMap.get(beanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 注册单例bean</span><br><span class="line">     *</span><br><span class="line">     * @param beanName bean名称</span><br><span class="line">     * @param bean 单例bean</span><br><span class="line">     */</span><br><span class="line">    public void registerSingletonBean(String beanName, Object bean) &#123;</span><br><span class="line">        if (singletonBeanMap.containsKey(beanName)) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        singletonBeanMap.put(beanName, bean);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="4、容器bean工厂"><a href="#4、容器bean工厂" class="headerlink" title="4、容器bean工厂"></a>4、容器bean工厂</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">public class BeanFactory &#123;</span><br><span class="line">    private Map&lt;String, BeanDefinition&gt; beanDefinitionMap = new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    private BeanRegister beanRegister;</span><br><span class="line"></span><br><span class="line">    public BeanFactory() &#123;</span><br><span class="line">        //创建bean注册器</span><br><span class="line">        beanRegister = new BeanRegister();</span><br><span class="line">        //加载资源</span><br><span class="line">        this.beanDefinitionMap = new ResourceLoader().getResource();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取bean</span><br><span class="line">     *</span><br><span class="line">     * @param beanName bean名称</span><br><span class="line">     * @return Object Bean</span><br><span class="line">     */</span><br><span class="line">    public Object getBean(String beanName) &#123;</span><br><span class="line">        //从bean缓存中取</span><br><span class="line">        Object bean = beanRegister.getSingletonBean(beanName);</span><br><span class="line">        if (bean != null) &#123;</span><br><span class="line">            return bean;</span><br><span class="line">        &#125;</span><br><span class="line">        //根据bean定义，创建bean</span><br><span class="line">        return createBean(beanDefinitionMap.get(beanName));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 创建Bean</span><br><span class="line">     *</span><br><span class="line">     * @param beanDefinition bean定义</span><br><span class="line">     * @return Object Bean</span><br><span class="line">     */</span><br><span class="line">    private Object createBean(BeanDefinition beanDefinition) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Object bean = beanDefinition.getBeanClass().newInstance();</span><br><span class="line">            //缓存bean</span><br><span class="line">            beanRegister.registerSingletonBean(beanDefinition.getBeanName(), bean);</span><br><span class="line">            return bean;</span><br><span class="line">        &#125; catch (InstantiationException | IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5、测试运行"><a href="#5、测试运行" class="headerlink" title="5、测试运行"></a>5、测试运行</h5><p><img src="/../images/spring-ioc/image-20240401201006715.png"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/09/01/Spring%E7%9A%84%E8%87%AA%E5%8A%A8%E5%8A%A0%E8%BD%BD%E9%85%8D%E7%BD%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="xiaozhigang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xiaozhigang">
      <meta itemprop="description" content="最后不知天在水，满船清梦压星河。">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | xiaozhigang">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/09/01/Spring%E7%9A%84%E8%87%AA%E5%8A%A8%E5%8A%A0%E8%BD%BD%E9%85%8D%E7%BD%AE/" class="post-title-link" itemprop="url">Spring的自动加载配置</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-09-01 20:35:49" itemprop="dateCreated datePublished" datetime="2022-09-01T20:35:49+08:00">2022-09-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JAVA/" itemprop="url" rel="index"><span itemprop="name">JAVA</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h3><p>都知道spring的自动加载是通过注解实现的，但是这注解又是怎么实现的呢？</p>
<p>通过@SpringBootApplication注解开启，读取配置文件中的配置类，然后过滤掉不需要的配置类，最后将剩余的配置类加载配置。</p>
<h3 id="具体过程"><a href="#具体过程" class="headerlink" title="具体过程"></a>具体过程</h3><p>上面说了一下大概的概念，接下来我们分析一下具体的执行过程。</p>
<h4 id="1、开启自动加载"><a href="#1、开启自动加载" class="headerlink" title="1、开启自动加载"></a>1、开启自动加载</h4><p>都知道自动开启加载注解@SpringBootApplication，但是这个注解是个复合注解，他是由多个注解合并而成，但是主要的是三个注解：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootConfiguration // 配置文件</span><br><span class="line">@EnableAutoConfiguration // 开启自动配置</span><br><span class="line">@ComponentScan // 扫描</span><br></pre></td></tr></table></figure>

<p><img src="/../images/spring/image-20240401205815186.png" alt="image-20240401205815186"></p>
<p>@EnableAutoConfiguration注解继续下钻，主要有@AutoConfigurationPackage和@Import({AutoConfigurationImportSelector.class})两个注解，@AutoConfigurationPackage继续下钻主要有@Import({AutoConfigurationPackages.Registrar.class})这个注解。</p>
<p><img src="/../images/spring/image-20250705155304630.png" alt="image-20250705155304630"></p>
<p>所以基本可以理解</p>
<p>@EnableAutoConfiguration &#x3D; @Import({AutoConfigurationImportSelector.class}) + @Import({AutoConfigurationPackages.Registrar.class})</p>
<p>即自动加载主要是依赖AutoConfigurationImportSelector.class，AutoConfigurationPackages.Registrar.class两个类。</p>
<h4 id="2、-EnableAutoConfiguration下的两个类"><a href="#2、-EnableAutoConfiguration下的两个类" class="headerlink" title="2、@EnableAutoConfiguration下的两个类"></a>2、@EnableAutoConfiguration下的两个类</h4><p>AutoConfigurationPackages.Registrar.class：作用就是获取要扫描的包路径</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">static class Registrar implements ImportBeanDefinitionRegistrar, DeterminableImports &#123;</span><br><span class="line">    Registrar() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void registerBeanDefinitions(AnnotationMetadata metadata, BeanDefinitionRegistry registry) &#123;</span><br><span class="line">        AutoConfigurationPackages.register(registry, (String[])(new PackageImports(metadata)).getPackageNames().toArray(new String[0]));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Set&lt;Object&gt; determineImports(AnnotationMetadata metadata) &#123;</span><br><span class="line">        return Collections.singleton(new PackageImports(metadata));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AutoConfigurationImportSelector.class：可以看到AutoConfigurationImportSelector实现了3种接口</p>
<p>1、DeferredImportSelector接口，继承了ImportSelector接口，用于bean的注入</p>
<p>2、以Aware结尾的接口，这类接口时为了完成某类资源的设置。</p>
<p>3、Ordered接口，用于指定bean的加载顺序。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class AutoConfigurationImportSelector implements DeferredImportSelector, BeanClassLoaderAware, ResourceLoaderAware, BeanFactoryAware, EnvironmentAware, Ordered</span><br></pre></td></tr></table></figure>

<h4 id="3、AutoConfigurationImportSelector"><a href="#3、AutoConfigurationImportSelector" class="headerlink" title="3、AutoConfigurationImportSelector"></a>3、AutoConfigurationImportSelector</h4><p>AutoConfigurationImportSelector实现了DeferredImportSelector接口，我们先看一下DeferredImportSelector接口。</p>
<p><img src="/../images/spring/image-20240401215546520.png" alt="image-20240401215546520"></p>
<p>接口里就包含了要加载的bean信息，再回到实现类，主要方法process。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void process(AnnotationMetadata annotationMetadata, DeferredImportSelector deferredImportSelector) &#123;</span><br><span class="line">	Assert.state(deferredImportSelector instanceof AutoConfigurationImportSelector,</span><br><span class="line">			() -&gt; String.format(&quot;Only %s implementations are supported, got %s&quot;,</span><br><span class="line">					AutoConfigurationImportSelector.class.getSimpleName(),</span><br><span class="line">					deferredImportSelector.getClass().getName()));</span><br><span class="line">					</span><br><span class="line">	// 获取自动配置的类</span><br><span class="line">	AutoConfigurationEntry autoConfigurationEntry = ((AutoConfigurationImportSelector) deferredImportSelector)</span><br><span class="line">			.getAutoConfigurationEntry(annotationMetadata);</span><br><span class="line">	this.autoConfigurationEntries.add(autoConfigurationEntry);</span><br><span class="line">	// 遍历自动配置的bean</span><br><span class="line">	for (String importClassName : autoConfigurationEntry.getConfigurations()) &#123;</span><br><span class="line">		// 如果存在这个类就进行加入</span><br><span class="line">		this.entries.putIfAbsent(importClassName, annotationMetadata);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，主要的就是获取自动配置类：getAutoConfigurationEntry方法</p>
<pre><code>protected AutoConfigurationEntry getAutoConfigurationEntry(AnnotationMetadata annotationMetadata) &#123;
    if (!isEnabled(annotationMetadata)) &#123;
        return EMPTY_ENTRY;
    &#125;
    AnnotationAttributes attributes = getAttributes(annotationMetadata);
    List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata, attributes); // 关键
    configurations = removeDuplicates(configurations);
    Set&lt;String&gt; exclusions = getExclusions(annotationMetadata, attributes);
    checkExcludedClasses(configurations, exclusions);
    configurations.removeAll(exclusions);
    configurations = getConfigurationClassFilter().filter(configurations);
    fireAutoConfigurationImportEvents(configurations, exclusions);
    return new AutoConfigurationEntry(configurations, exclusions);
&#125;
</code></pre>
<p>根据关键代码继续下钻</p>
<pre><code>protected List&lt;String&gt; getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) &#123;
    List&lt;String&gt; configurations = new ArrayList&lt;&gt;(
            SpringFactoriesLoader.loadFactoryNames(getSpringFactoriesLoaderFactoryClass(), getBeanClassLoader()));
    ImportCandidates.load(AutoConfiguration.class, getBeanClassLoader()).forEach(configurations::add);
    Assert.notEmpty(configurations,
            &quot;No auto configuration classes found in META-INF/spring.factories nor in META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports. If you &quot;
                    + &quot;are using a custom packaging, make sure that file is correct.&quot;);
    return configurations;
&#125;
</code></pre>
<p>继续下钻</p>
<p><img src="/../images/spring/image-20240401232921570.png" alt="image-20240401232921570"></p>
<p>到这就基本清楚了，这里加载了META-INF&#x2F;spring.factories文件下的配置，然后返回到getAutoConfigurationEntry方法里进行过滤，当然过滤的方式也是按条件注解<code>@ConditionalOnxxx</code>过滤生效。</p>
<p><img src="/../images/spring/image-20240401233308499.png" alt="image-20240401233308499"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>@SpringBootApplication下分三个注解，@EnableAutoConfiguration注解负责自动加载配置，</p>
<p>@EnableAutoConfiguration注解又引入两个类，AutoConfigurationImportSelector.class 和 AutoConfigurationPackages.Registrar.class</p>
<p>主要逻辑都在AutoConfigurationImportSelector.class中，此类中有个getAutoConfigurationEntry方法，</p>
<p>这个方法调用了两个方法getCandidateConfigurations 加载  和 getConfigurationClassFilter().filter 过滤。</p>
<p>如此加载进了配置文件中的配置，过滤了条件不满足的配置，以达到开箱即用。</p>
<p><img src="/../images/spring/image-20240401234620520.png" alt="image-20240401234620520"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/08/11/Spring%E4%B8%AD%E7%94%A8%E5%88%B0%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="xiaozhigang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xiaozhigang">
      <meta itemprop="description" content="最后不知天在水，满船清梦压星河。">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | xiaozhigang">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/08/11/Spring%E4%B8%AD%E7%94%A8%E5%88%B0%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" class="post-title-link" itemprop="url">Spring中用到的设计模式</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-08-11 18:57:44" itemprop="dateCreated datePublished" datetime="2022-08-11T18:57:44+08:00">2022-08-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JAVA/" itemprop="url" rel="index"><span itemprop="name">JAVA</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><p><strong>Spring AOP 就是基于代理模式</strong>，被代理对象有实现某个接口，则用<strong>JDK Proxy</strong>创建对象，没有实现接口则用<strong>Cglib</strong>创建代理对象。</p>
<p>当然也可以使用AspectJ，AspectJ是Java生态系统中最完整的AOP框架。</p>
<p><img src="/../images/design/image-20240414185312122.png" alt="image-20240414185312122"></p>
<p><strong>Spring AOP属于运行时增强，AspectJ是编译时增强。</strong></p>
<table>
<thead>
<tr>
<th></th>
<th>Spring AOP</th>
<th>AspectJ</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>与spring ioc紧密集成，新项目使用</td>
<td>维护老项目使用</td>
</tr>
<tr>
<td>2</td>
<td>运行时织入</td>
<td>编译时生成</td>
</tr>
<tr>
<td>3</td>
<td>不支持static和final修饰方法和类</td>
<td>支持</td>
</tr>
<tr>
<td>4</td>
<td>简单，有注解</td>
<td>复杂，需要.aj文件来创建切面，并且需要使用ajc来编译代码</td>
</tr>
</tbody></table>
<p>两者异同：<a target="_blank" rel="noopener" href="https://developer.aliyun.com/article/720402">https://developer.aliyun.com/article/720402</a></p>
<h3 id="模板方法"><a href="#模板方法" class="headerlink" title="模板方法"></a>模板方法</h3><p>父类定义算法骨架或者关键步骤，而具体实现延迟到子类中，使子类再不改变父类结构的情况下可重定义某些特定步骤的实现。</p>
<p>Spring 中 <code>JdbcTemplate</code>、<code>HibernateTemplate</code> 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。一般情况下，我们都是使用继承的方式来实现模板模式，但是 Spring 并没有使用这种方式，而是使用 Callback 模式与模板方法模式配合，既达到了代码复用的效果，同时增加了灵活性。定义了资源获取、执行SQL、释放资源这些基本流程，执行sql的具体方式又以回调函数的形式开放。</p>
<p><img src="/../images/design/image-20240414192751147.png" alt="image-20240414192751147"></p>
<p>参考文献：<a target="_blank" rel="noopener" href="https://blog.csdn.net/zhangweiocp/article/details/115486257">https://blog.csdn.net/zhangweiocp/article/details/115486257</a></p>
<h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><p>观察者模式是一种对象行为型模式。它表示的是一种对象与对象之间具有依赖关系，当一个对象发生改变的时候，依赖这个对象的所有对象也会做出反应。Spring 事件驱动模型就是观察者模式很经典的一个应用。Spring 事件驱动模型非常有用，在很多场景都可以解耦我们的代码。比如我们每次添加商品的时候都需要重新更新商品索引，这个时候就可以利用观察者模式来解决这个问题。</p>
<p>事件驱动模型中的三种角色：事件角色、事件监听者角色、事件发布者角色。</p>
<p><img src="/../images/design/image-20240414190146289.png" alt="image-20240414190146289"></p>
<p><strong>spring的事件流程总结</strong></p>
<p>1、定义一个事件: 实现一个继承自<code>ApplicationEvent</code>，并且写相应的构造函数</p>
<p>2、定义一个事件监听者：实现 <code>ApplicationListener</code> 接口，重写 <code>onApplicationEvent()</code> 方法</p>
<p>3、使用事件发布者发布消息: 可以通过 <code>ApplicationEventPublisher</code> 的 <code>publishEvent()</code> 方法发布消息</p>
<p>example:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">// 定义一个事件,继承自ApplicationEvent并且写相应的构造函数</span><br><span class="line">public class DemoEvent extends ApplicationEvent&#123;</span><br><span class="line">    private static final long serialVersionUID = 1L;</span><br><span class="line"></span><br><span class="line">    private String message;</span><br><span class="line"></span><br><span class="line">    public DemoEvent(Object source,String message)&#123;</span><br><span class="line">        super(source);</span><br><span class="line">        this.message = message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getMessage() &#123;</span><br><span class="line">         return message;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 定义一个事件监听者,实现ApplicationListener接口，重写 onApplicationEvent() 方法；</span><br><span class="line">@Component</span><br><span class="line">public class DemoListener implements ApplicationListener&lt;DemoEvent&gt;&#123;</span><br><span class="line"></span><br><span class="line">    //使用onApplicationEvent接收消息</span><br><span class="line">    @Override</span><br><span class="line">    public void onApplicationEvent(DemoEvent event) &#123;</span><br><span class="line">        String msg = event.getMessage();</span><br><span class="line">        System.out.println(&quot;接收到的信息是：&quot;+msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">// 发布事件，可以通过ApplicationEventPublisher  的 publishEvent() 方法发布消息。</span><br><span class="line">@Component</span><br><span class="line">public class DemoPublisher &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">    public void publish(String message)&#123;</span><br><span class="line">        //发布事件</span><br><span class="line">        applicationContext.publishEvent(new DemoEvent(this, message));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当调用 <code>DemoPublisher</code> 的 <code>publish()</code> 方法的时候，比如 <code>demoPublisher.publish(&quot;你好&quot;)</code> ，控制台就会打印出:<code>接收到的信息是：你好</code> 。</p>
<h3 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h3><p>装饰者模式可以动态地给对象添加一些额外的属性或行为。相比于使用继承，装饰者模式更加灵活。简单点儿说就是当我们需要修改原有的功能，但我们又不愿直接去修改原有的代码时，设计一个 Decorator 套在原有代码外面。最典型的就是JDK中的<code>InputStream,OutputStream</code>，两个类下的所有子类都是再不修改父类代码的情况下扩展了他的功能。</p>
<p><img src="/../images/design/Decorator.jpg" alt="装饰者模式示意图"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Spring 框架中用到了哪些设计模式？</p>
<ul>
<li><strong>工厂设计模式</strong> : Spring 使用工厂模式通过 <code>BeanFactory</code>、<code>ApplicationContext</code> 创建 bean 对象。</li>
<li><strong>代理设计模式</strong> : Spring AOP 功能的实现。</li>
<li><strong>单例设计模式</strong> : Spring 中的 Bean 默认都是单例的。</li>
<li><strong>模板方法模式</strong> : Spring 中 <code>jdbcTemplate</code>、<code>hibernateTemplate</code> 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。</li>
<li><strong>包装器设计模式</strong> : 我们的项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们可以根据客户的需求能够动态切换不同的数据源。</li>
<li><strong>观察者模式:</strong> Spring 事件驱动模型就是观察者模式很经典的一个应用。</li>
<li><strong>适配器模式</strong> :Spring AOP 的增强或通知(Advice)使用到了适配器模式、spring MVC 中也是用到了适配器模式适配<code>Controller</code>l</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/07/16/Git%E5%88%86%E6%94%AF%E6%A8%A1%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="xiaozhigang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xiaozhigang">
      <meta itemprop="description" content="最后不知天在水，满船清梦压星河。">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | xiaozhigang">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/07/16/Git%E5%88%86%E6%94%AF%E6%A8%A1%E5%9E%8B/" class="post-title-link" itemprop="url">Git分支模型(参考阿里Aone Flow)</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-07-16 15:28:52" itemprop="dateCreated datePublished" datetime="2022-07-16T15:28:52+08:00">2022-07-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Git/" itemprop="url" rel="index"><span itemprop="name">Git</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="分支定义"><a href="#分支定义" class="headerlink" title="分支定义"></a>分支定义</h2><ol>
<li><p>master</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">长期分支，存在与整个项目开发过程。</span><br><span class="line"></span><br><span class="line">由项目主要技术负责人管理该分支。</span><br></pre></td></tr></table></figure>
</li>
<li><p>release&#x2F;xxx</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">release/test 和 release/prod</span><br><span class="line">既可以为长期分支也可以为短期分支，可能存在于一个或者多个版本之间.</span><br><span class="line"></span><br><span class="line">由测试负责人负责人管理该分支。</span><br></pre></td></tr></table></figure>
</li>
<li><p>feature&#x2F;fixbug&#x2F;hotfix</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">临时分支</span><br><span class="line">用于开发的具体功能特性和修复bug的分支，功能完成后删除.</span><br><span class="line">格式为：feature_$date_$name_$description</span><br><span class="line">       fixbug_$date_$name_$description</span><br><span class="line">       hotfix_$date_$name_$description</span><br></pre></td></tr></table></figure></li>
</ol>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2022/07/16/Git%E5%88%86%E6%94%AF%E6%A8%A1%E5%9E%8B/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/07/16/Java%20Ai%20Interview%20Guide/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="xiaozhigang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xiaozhigang">
      <meta itemprop="description" content="最后不知天在水，满船清梦压星河。">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | xiaozhigang">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/07/16/Java%20Ai%20Interview%20Guide/" class="post-title-link" itemprop="url">Git分支模型(参考阿里Aone Flow)</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-07-16 15:28:52" itemprop="dateCreated datePublished" datetime="2022-07-16T15:28:52+08:00">2022-07-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Git/" itemprop="url" rel="index"><span itemprop="name">Git</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="技术面试复习清单（Java-后端-AI-应用方向）"><a href="#技术面试复习清单（Java-后端-AI-应用方向）" class="headerlink" title="技术面试复习清单（Java 后端 + AI 应用方向）"></a>技术面试复习清单（Java 后端 + AI 应用方向）</h2><hr>
<h3 id="✅-第一部分：Java-后端面试重点复习"><a href="#✅-第一部分：Java-后端面试重点复习" class="headerlink" title="✅ 第一部分：Java 后端面试重点复习"></a>✅ 第一部分：Java 后端面试重点复习</h3><h4 id="🍃-Java-核心"><a href="#🍃-Java-核心" class="headerlink" title="🍃 Java 核心"></a>🍃 Java 核心</h4><ul>
<li><p>Java基础：</p>
<ul>
<li><p>集合类实现原理（HashMap 的哈希冲突解决、负载因子、扩容机制）</p>
<ul>
<li><p>示例：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/skywang12345/p/3312722.html">HashMap源码剖析</a></p>
</li>
<li><table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>哈希冲突解决</td>
<td>链表法 + 红黑树</td>
</tr>
<tr>
<td>默认负载因子</td>
<td>0.75</td>
</tr>
<tr>
<td>扩容阈值</td>
<td>当前容量 × 负载因子</td>
</tr>
<tr>
<td>扩容倍数</td>
<td>每次扩容为原来的 2 倍</td>
</tr>
<tr>
<td>红黑树转化阈值</td>
<td>链表长度 &gt; 8，且桶数组长度 &gt; 64</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li><p>List 与 Set 的区别，线程安全集合使用（CopyOnWriteArrayList、ConcurrentHashMap）</p>
<ul>
<li><p>说明：<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904046436849672">集合类对比总结</a></p>
</li>
<li><table>
<thead>
<tr>
<th>项目</th>
<th>List</th>
<th>Set</th>
</tr>
</thead>
<tbody><tr>
<td>是否允许重复元素</td>
<td>✅ 允许</td>
<td>❌ 不允许</td>
</tr>
<tr>
<td>是否有顺序</td>
<td>✅ 有插入顺序</td>
<td>❌ 无顺序（<code>HashSet</code>），但<code>TreeSet</code>有排序</td>
</tr>
<tr>
<td>常见实现类</td>
<td><code>ArrayList</code>, <code>LinkedList</code>, <code>Vector</code></td>
<td><code>HashSet</code>, <code>LinkedHashSet</code>, <code>TreeSet</code></td>
</tr>
<tr>
<td>底层结构</td>
<td><code>ArrayList</code>: 数组<code>LinkedList</code>: 双向链表</td>
<td><code>HashSet</code>: HashMap 实现<code>TreeSet</code>: 红黑树</td>
</tr>
<tr>
<td>查找效率</td>
<td><code>ArrayList</code> 是 O(1)（索引查找）</td>
<td><code>HashSet</code> 是 O(1)，<code>TreeSet</code> 是 O(logN)</td>
</tr>
<tr>
<td>使用场景</td>
<td>需要按顺序存储、可重复数据</td>
<td>要求元素唯一性、不关注顺序</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
</ul>
</li>
<li><p>多线程与并发：</p>
<ul>
<li>线程创建方式（Thread、Runnable、Callable）及线程池（Executors）</li>
<li>synchronized 与 ReentrantLock 区别</li>
<li>volatile 原理、内存可见性、指令重排序<ul>
<li>案例：<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903857554018318">并发可见性例子</a></li>
</ul>
</li>
<li>原子类（AtomicInteger、LongAdder）与 CAS 实现</li>
<li>并发工具类：CountDownLatch、CyclicBarrier、Semaphore<ul>
<li>示例：<a target="_blank" rel="noopener" href="https://www.baeldung.com/java-concurrent-utilities">并发工具类实战</a></li>
</ul>
</li>
</ul>
</li>
<li><p>JVM：</p>
<ul>
<li>JVM 内存区域（堆、栈、方法区、直接内存）</li>
<li>类加载机制（双亲委派）、类卸载机制<ul>
<li>参考：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/aspirant/p/12222246.html">JVM类加载机制详解</a></li>
</ul>
</li>
<li>GC 垃圾回收算法（标记-清除、复制、CMS、G1）<ul>
<li>可视化演示：<a target="_blank" rel="noopener" href="https://gceasy.io/">JVM GC动画讲解</a></li>
</ul>
</li>
<li>性能调优工具（jstack、jmap、jvisualvm）</li>
</ul>
</li>
</ul>
<h4 id="🌐-Spring-Spring-Boot"><a href="#🌐-Spring-Spring-Boot" class="headerlink" title="🌐 Spring &amp; Spring Boot"></a>🌐 Spring &amp; Spring Boot</h4><ul>
<li>IOC &#x2F; AOP原理：BeanFactory 与 ApplicationContext，动态代理、切面编程</li>
<li>Bean 生命周期：构造 -&gt; set 属性 -&gt; 初始化 -&gt; 销毁</li>
<li>常用注解原理（@Transactional 的事务传播行为与回滚机制）</li>
<li>自动配置原理：SpringFactoriesLoader、条件注解（@ConditionalOnMissingBean）<ul>
<li>案例：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/135354270">Spring Boot 自动配置原理</a></li>
</ul>
</li>
</ul>
<h4 id="🛠️-数据库-缓存"><a href="#🛠️-数据库-缓存" class="headerlink" title="🛠️ 数据库 &amp; 缓存"></a>🛠️ 数据库 &amp; 缓存</h4><ul>
<li>MySQL：<ul>
<li>索引类型（B+树）、覆盖索引、联合索引与最左匹配原则</li>
<li>SQL 调优（explain 分析、慢查询日志）</li>
<li>事务隔离级别（Read Uncommitted、Repeatable Read 等）与幻读、MVCC 实现<ul>
<li>MVCC讲解：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/117601718">图解MVCC</a></li>
</ul>
</li>
</ul>
</li>
<li>Redis：<ul>
<li>数据结构（String、List、Set、Hash、ZSet）典型应用场景</li>
<li>持久化机制（RDB vs AOF）、主从复制、哨兵机制</li>
<li>缓存击穿（互斥锁）、穿透（布隆过滤器）、雪崩（过期时间错开）处理<ul>
<li>案例：<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904127748911117">Redis缓存问题解决方案</a></li>
</ul>
</li>
<li>分布式锁（SET NX PX 实现原理、Redlock 分布式算法）<ul>
<li>源码分析：<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903985725276167">Redlock 机制</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="🧱-中间件"><a href="#🧱-中间件" class="headerlink" title="🧱 中间件"></a>🧱 中间件</h4><ul>
<li>Kafka：<ul>
<li>Producer&#x2F;Consumer 原理、分区机制、消费位移管理</li>
<li>消费模式（at most once、at least once）、幂等性保证</li>
</ul>
</li>
<li>RabbitMQ：<ul>
<li>交换机类型（Direct、Fanout、Topic）、消息确认与重试</li>
</ul>
</li>
<li>Netty：事件驱动模型、零拷贝、Reactor 模式</li>
<li>Nginx：反向代理、负载均衡、location 匹配规则、缓存设置<ul>
<li>配置案例：<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903871032328205">Nginx使用详解</a></li>
</ul>
</li>
<li>分布式ID：UUID 特点、雪花算法结构（时间戳+机器ID+序列号）</li>
</ul>
<h4 id="⚙️-系统设计-分布式"><a href="#⚙️-系统设计-分布式" class="headerlink" title="⚙️ 系统设计 &#x2F; 分布式"></a>⚙️ 系统设计 &#x2F; 分布式</h4><ul>
<li>微服务架构：服务注册发现（Eureka&#x2F;Nacos）、配置中心（Spring Cloud Config）</li>
<li>分布式事务：<ul>
<li>TCC（Try-Confirm-Cancel）原理与应用</li>
<li>可靠消息最终一致性（RocketMQ事务消息）</li>
<li>SAGA 状态机模式（流程编排）</li>
</ul>
</li>
<li>限流熔断降级：<ul>
<li>Hystrix：断路器、舱壁、降级策略</li>
<li>Sentinel：滑动窗口限流、预热、熔断规则设置<ul>
<li>官方示例：<a target="_blank" rel="noopener" href="https://github.com/alibaba/Sentinel/wiki">Sentinel 使用文档</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="✅-第二部分：AI-应用相关知识点"><a href="#✅-第二部分：AI-应用相关知识点" class="headerlink" title="✅ 第二部分：AI 应用相关知识点"></a>✅ 第二部分：AI 应用相关知识点</h3><h4 id="🤖-LLM-应用开发基础（LangChain-Flowise-OpenAI-API）"><a href="#🤖-LLM-应用开发基础（LangChain-Flowise-OpenAI-API）" class="headerlink" title="🤖 LLM 应用开发基础（LangChain &#x2F; Flowise &#x2F; OpenAI API）"></a>🤖 LLM 应用开发基础（LangChain &#x2F; Flowise &#x2F; OpenAI API）</h4><ul>
<li>Prompt Engineering：角色设定、上下文拼接、few-shot 提示设计<ul>
<li>指南：<a target="_blank" rel="noopener" href="https://platform.openai.com/docs/guides/gpt-best-practices">OpenAI Prompt Best Practices</a></li>
</ul>
</li>
<li>LangChain 模块：<ul>
<li>LLMChain：单轮调用链</li>
<li>RetrievalQA：向量搜索增强问答</li>
<li>Agent：动态任务调度</li>
<li>Memory：对话历史上下文管理（BufferMemory、SummaryMemory）<ul>
<li>文档：<a target="_blank" rel="noopener" href="https://python.langchain.com/docs/modules/memory/">LangChain Memory</a></li>
</ul>
</li>
</ul>
</li>
<li>向量数据库：<ul>
<li>Faiss：本地索引（Flat、IVF、HNSW）、Index 保存&#x2F;加载方式</li>
<li>Chroma &#x2F; Weaviate：文档分片、元数据存储与过滤检索<ul>
<li>参考：<a target="_blank" rel="noopener" href="https://weaviate.io/">Weaviate 向量数据库</a></li>
</ul>
</li>
</ul>
</li>
<li>Embedding：<ul>
<li>OpenAI text-embedding-ada-002 使用方式、维度、成本</li>
<li>HuggingFace Sentence Transformers 示例（all-MiniLM）<ul>
<li>示例项目：<a target="_blank" rel="noopener" href="https://www.sbert.net/docs/quickstart.html">Sentence Transformers 快速上手</a></li>
</ul>
</li>
</ul>
</li>
<li>RAG：文档分片 ➝ embedding ➝ 存入向量库 ➝ 查询补全 context ➝ LLM 回答</li>
<li>OpenAI 接口：API Key、temperature、top_p、stream 流式输出、速率限制处理<ul>
<li>官方文档：<a target="_blank" rel="noopener" href="https://platform.openai.com/docs/api-reference/chat/create">OpenAI API</a></li>
</ul>
</li>
</ul>
<h4 id="💾-向量库与检索应用"><a href="#💾-向量库与检索应用" class="headerlink" title="💾 向量库与检索应用"></a>💾 向量库与检索应用</h4><ul>
<li>Faiss 操作：<ul>
<li>构建索引：IndexFlatL2、IndexIVFFlat</li>
<li>插入数据：add_with_ids</li>
<li>查询相似向量：search(query, k)</li>
<li>快速入门：<a target="_blank" rel="noopener" href="https://github.com/facebookresearch/faiss/wiki/Indexing-1M-vectors">Faiss官方示例</a></li>
</ul>
</li>
<li>向量检索原理：L2距离、Cosine 相似度、内积</li>
<li>本地 vs 云部署：FastAPI + Uvicorn 封装 Faiss API 远程调用<ul>
<li>项目示例：<a target="_blank" rel="noopener" href="https://github.com/tiangolo/full-stack-fastapi-postgresql">本地部署Faiss + FastAPI</a></li>
</ul>
</li>
</ul>
<h4 id="🧠-Java-接入-AI-方向"><a href="#🧠-Java-接入-AI-方向" class="headerlink" title="🧠 Java 接入 AI 方向"></a>🧠 Java 接入 AI 方向</h4><ul>
<li>接入方式：<ul>
<li>使用 WebClient &#x2F; OkHttp &#x2F; Feign 调用 OpenAI 接口</li>
<li>解析 JSON 响应并集成流式 SSE 输出</li>
</ul>
</li>
<li>LangChain4j：<ul>
<li>使用 PromptTemplate + OpenAiLanguageModel 构建聊天功能</li>
<li>与 Redis &#x2F; 向量库集成构建知识问答<ul>
<li>项目参考：<a target="_blank" rel="noopener" href="https://github.com/langchain4j/langchain4j">LangChain4j</a></li>
</ul>
</li>
</ul>
</li>
<li>Demo 项目：<ul>
<li>Java ChatPDF 实现：上传 PDF ➝ 分词 ➝ embedding ➝ 存储 ➝ 问答接口</li>
</ul>
</li>
</ul>
<hr>
<h3 id="📋-Bonus：系统设计类面试常见题目（准备简要方案）"><a href="#📋-Bonus：系统设计类面试常见题目（准备简要方案）" class="headerlink" title="📋 Bonus：系统设计类面试常见题目（准备简要方案）"></a>📋 Bonus：系统设计类面试常见题目（准备简要方案）</h3><ol>
<li>高并发电商下单系统：库存缓存、异步削峰（MQ）、分布式锁、防重提交</li>
<li>聊天记录搜索：切分聊天文本 ➝ embedding ➝ 存 Faiss ➝ 模糊匹配</li>
<li>智能问答机器人系统：文档预处理 ➝ 向量库 ➝ RAG 模式 ➝ LLM 调用</li>
<li>Java 服务接 GPT-4 生成摘要：接口设计、鉴权、token 管控、缓存存储</li>
<li>简易 LangChain Chat Bot：Java 封装接口 + LangChain4j agent + memory 实现</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/21/MySQL%E4%B8%A4%E6%AE%B5%E5%BC%8F%E6%8F%90%E4%BA%A4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="xiaozhigang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xiaozhigang">
      <meta itemprop="description" content="最后不知天在水，满船清梦压星河。">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | xiaozhigang">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/06/21/MySQL%E4%B8%A4%E6%AE%B5%E5%BC%8F%E6%8F%90%E4%BA%A4/" class="post-title-link" itemprop="url">MySQL两段式提交</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-06-21 22:04:58" itemprop="dateCreated datePublished" datetime="2022-06-21T22:04:58+08:00">2022-06-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/MySQL/" itemprop="url" rel="index"><span itemprop="name">MySQL</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>两段式提交是MySQL数据持久化的保证。</p>
<h2 id="两种日志"><a href="#两种日志" class="headerlink" title="两种日志"></a>两种日志</h2><h3 id="binlog和redolog"><a href="#binlog和redolog" class="headerlink" title="binlog和redolog"></a>binlog和redolog</h3><p>binlog记录了数据库表结构和表数据变更，主要有两个作用：复制和恢复数据</p>
<p>redo log 是 Innodb 引擎独有的日志模块，它只记录有关 Innodb 引擎的事务日志，记录内容为 对数据页的物理操作</p>
<table>
<thead>
<tr>
<th></th>
<th>binlog</th>
<th>redolog</th>
</tr>
</thead>
<tbody><tr>
<td>适用对象不同</td>
<td>mysql server 层</td>
<td>Innodb 存储引擎层</td>
</tr>
<tr>
<td>写入方式不同适用对象不同</td>
<td>追加写，一个文件满了写新文件mysql server 层</td>
<td>循环写固定文件Innodb 存储引擎层</td>
</tr>
<tr>
<td>写入方式不同</td>
<td>逻辑日志，一个事务具体操作内容</td>
<td>物理日志，页的修改情况</td>
</tr>
<tr>
<td>写入磁盘时间不同</td>
<td>提交事务前一次写入</td>
<td>在事务进行中有后台线程不断同步</td>
</tr>
<tr>
<td>用途不同</td>
<td>主从复制、数据备份</td>
<td>数据恢复</td>
</tr>
</tbody></table>
<h2 id="两段式提交"><a href="#两段式提交" class="headerlink" title="两段式提交"></a>两段式提交</h2><p>两种日志虽然都保证持久化，但是侧重点不同。</p>
<p>1、redo log（重做日志）让InnoDB存储引擎拥有了崩溃恢复能力。</p>
<p>2、binlog（归档日志）保证了MySQL集群架构的数据一致性，主从节点的同步都是通过binlog保证的。</p>
<p>如果<strong>单独提交</strong><br>先写 redo log 后写 binlog，也就是事务可能还没有提交，系统崩溃了，虽然可以通过redo log恢复，但是binlog还没有这条数据，就会造成主从不一致 先写 binlog 后写 redo log，这个过程说明事务已经提交了，系统崩溃了，虽然binlog里面有数据，但是redo log里面没有，也会发生主从不一致，并且redo log因为不全，即使重新恢复的时候也不是最新的数据</p>
<h3 id="两段式提交-1"><a href="#两段式提交-1" class="headerlink" title="两段式提交"></a>两段式提交</h3><p>就是将redolog的提交拆为两各阶段，prepare阶段和commit阶段，在中间插入binlog提交。</p>
<p><img src="/../images/MySQL-submit/image-20240326231349218.png" alt="image-20240326231349218"></p>
<h3 id="发生异常"><a href="#发生异常" class="headerlink" title="发生异常"></a>发生异常</h3><p>1、在prepare阶段写入redolog的时候发生异常，那不管redolog有没有写完，都会回滚，因为binlog没有写入，会导致日志不一样，主从数据不一致。</p>
<p>2、在commit阶段写入binlog的时候发生异常</p>
<pre><code>    如果在写完之前，那也会回滚，毕竟没写完和没写一样，会导致日志不一样，主从数据不一样。

    如果在写完之后，那就不会回滚了，两种日志都写完了，能保证数据一致了。
</code></pre>
<p>3、在commit阶段提交redolog的时候发生异常，前面写完binlog就不会回滚了，那这里也不会回滚，能保证数据一致性。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/05/16/MySQL%E7%9A%84%E5%9B%9E%E8%A1%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="xiaozhigang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xiaozhigang">
      <meta itemprop="description" content="最后不知天在水，满船清梦压星河。">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | xiaozhigang">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/05/16/MySQL%E7%9A%84%E5%9B%9E%E8%A1%A8/" class="post-title-link" itemprop="url">MySQL的回表</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-05-16 20:05:50" itemprop="dateCreated datePublished" datetime="2022-05-16T20:05:50+08:00">2022-05-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/MySQL/" itemprop="url" rel="index"><span itemprop="name">MySQL</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>说起回表，肯定要说起MySQL的存储结构B+树。</p>
<p>每条数据是以主键和数据的形式存放在B+树的节点上，如果我们通过主键查询的话，直接通过和节点上的主键比较判断，相等的话直接取。</p>
<p>其他索引是将索引和主键值放在一起的，通过索引查到主键，在通过主键去查找数据。这也就是为什么主键索引会比其他索引快。</p>
<h2 id="主键查询"><a href="#主键查询" class="headerlink" title="主键查询"></a>主键查询</h2><p>主键和数据是通过B+数的形式存储的，查的时候肯定也是通过树的查询方式查询的。如下图查询主键Id为4的数据，先根据根节点查询，4小于10，再往子节点查找，然后跟子节点的值比较，在2、4之间，再寻找这区间的节点，第一个值是3，不匹配，在查找下一个，值是4匹配，放回数据记录data。</p>
<p><img src="/../images/MySQL-index/58766bb4795d68c3b07e87d644a4d428.webp" alt="img"></p>
<h2 id="非主键索引查询"><a href="#非主键索引查询" class="headerlink" title="非主键索引查询"></a>非主键索引查询</h2><p>其实和主键查询差不多，只不过相当于两次主键索引查询，第一个查询到的不是数据，是主键值，再根据主键值，按照主键索引查询再来一次。如图，如果数据有一条数据是2019-04-01创建的，数据的主键id为4，我们想根据这个创建时间（不知道主键id）找到这条数据。那就是先根据创建时间找到主键4，后根据主键4找到记录数据data。</p>
<p><img src="/../images/MySQL-index/2f0c5be33615ff0c340888bcc098a189.webp" alt="img"></p>
<h2 id="回表"><a href="#回表" class="headerlink" title="回表"></a>回表</h2><p>分主键索引相当于两次查询，第一次查询主键，第二次查询数据，将第二次查询的数据结果放回给第一次查询结果，就叫回表。按照上面的图示，就是将data放回到创建时间的查询中。</p>
<h3 id="覆盖查询"><a href="#覆盖查询" class="headerlink" title="覆盖查询"></a>覆盖查询</h3><p>使用非主键查询的时候，也会存在不用回表的情况，这种叫做覆盖查询。</p>
<p>什么是覆盖查询呢，就是在我们使用索引的时候，索引本身包含的数据字段已经满足查询要求的字段了，就不用具体根据主键去找具体的记录数据了。</p>
<p>如果有一份人员信息数据，存有名称，性别，出生日期和其他一些字段。由于通过出生日期和性别的查询较多，我们用这两个字段构建了一个联合索引。现在我们要查询2019-04-01出生的女孩人数。</p>
<p>如图，联合索引按出生日期和性别联合构建的索引，先按出生日期排序，再按性别排序。通过索引，查询到只有一个主键为4满足，这时候我们需要计数，因为主键是唯一的，也不需要我们通过主键再次查询了，计算主键数量就够了，直接返回1。这就不用回表。</p>
<p><img src="/../images/MySQL-index/c379c97c3c8519501326ec8dc6b7f60f.webp" alt="img"></p>
<h3 id="最左覆盖原则"><a href="#最左覆盖原则" class="headerlink" title="最左覆盖原则"></a>最左覆盖原则</h3><p>上面我们说到根据联合索引查询，其实联合索引有两个值，我们只根据一个值去查询的，但也查询到了。这是为啥呢，这就是最左覆盖原则。根据我们的查询条件，会匹配索引，从左边第一个字段开始，所以我们查询的时候有条件过滤最好和索引顺序一直。如上图，我们查询的是整个表里面有女生多少人就没办法走联合索引了。</p>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>是不是觉得这个B+树还挺好用的，思路挺清晰的。但是如果我们的B+树层级很深，是不是查询比较的次数就多了，耗时也就多了，也就不好用了。所以大家知道B+树有多少层吗？</p>
<p>B+树一般是3<del>4层，为啥说3</del>4层呢，这也是个计算值，我们看一下具体怎么计算的。</p>
<p>MySQL的引擎是InnoDB，InnoDB默认页大小是16k，当然也可以设置，B+树的每个节点都是一页。从上面可以知道，节点分为数据节点和非数据节点，</p>
<p>在数据节点中，通常数据大小为1k，16k &#x2F; 1k &#x3D; 16，也就是每个数据页中大概会存放16条数据。</p>
<p>在非数据节点中，主要存放的是主键ID和指针，主键大概8字节，指针大概6字节，总共14字节，1k&#x3D;1024字节，整页可以存放1170个（16 * 1024 &#x2F; 14 &#x3D; 1170）。</p>
<p>在3层的情况下，2层非数据节点，1层数据节点，可以存放大概21902400条数据。1170<em>1170</em>16&#x3D;21902400，已经到千万级别了，一个表里放千万条数据已经很大了，再大就要考虑分库分表了。</p>
<p><img src="/../images/MySQL-index/20ae97fc3959cd209f27dabd2f6f43e8.webp" alt="img"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/05/08/HashMap%E5%92%8CConcurrentHashMap%E7%9A%84put%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="xiaozhigang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xiaozhigang">
      <meta itemprop="description" content="最后不知天在水，满船清梦压星河。">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | xiaozhigang">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/05/08/HashMap%E5%92%8CConcurrentHashMap%E7%9A%84put%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/" class="post-title-link" itemprop="url">HashMap和ConcurrentHashMap的put方法详解</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-05-08 21:07:31" itemprop="dateCreated datePublished" datetime="2022-05-08T21:07:31+08:00">2022-05-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JAVA/" itemprop="url" rel="index"><span itemprop="name">JAVA</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="结构简述"><a href="#结构简述" class="headerlink" title="结构简述"></a>结构简述</h2><p>HashMap和ConcurrentHashMap的结构都是一样的，jdk1.8之后都是  数组+链表+红黑树，链表长度超过8之后转红黑树。</p>
<p>计算</p>
<p>节点为6个的时候，链表的平均查询时间：(1+2+3+4+5+6)&#x2F; 6 &#x3D; 3.5，红黑树的平均查询时间 (1+2<em>2+3</em>3)&#x2F;6&#x3D;2.3</p>
<p>节点为7个的时候，链表的平均查询时间：(1+2+3+4+5+6+7)&#x2F; 7 &#x3D; 4，红黑树的平均查询时间 (1+2<em>2+3</em>4)&#x2F;7&#x3D;2.4</p>
<p>节点为8个的时候，链表的平均查询时间：(1+2+3+4+5+6+7+8)&#x2F; 8 &#x3D; 4.5，红黑树的平均查询时间 (1+2<em>2+3</em>4+1*4)&#x2F;8&#x3D;2.6</p>
<p>链表的时间复杂度为O(n)，而树的时间复杂度为O(ln n)，上面计算有明显的效率变化，至于为啥选8这个阈值，应该是基于大量数据收集之后比较而定的。</p>
<h3 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h3><p><img src="/../images/HashMap/e890825ae4e552904f23d0af9dd2dba8.webp"></p>
<h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h3><p><img src="/../images/HashMap/4c43ad59e6d9647f7a7ae3c1d2ed668e.webp" alt="img"></p>
<h3 id="代码详解"><a href="#代码详解" class="headerlink" title="代码详解"></a>代码详解</h3><p><img src="/../images/HashMap/4234473148fe5ddc2845eee9d7745e08.webp"></p>
<h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><h3 id="流程图-1"><a href="#流程图-1" class="headerlink" title="流程图"></a>流程图</h3><p><img src="/../images/HashMap/9087d590fa217eb27e7ca95bde84583f.webp"></p>
<h3 id="代码详解-1"><a href="#代码详解-1" class="headerlink" title="代码详解"></a>代码详解</h3><p><img src="/../images/HashMap/937fe4d4a476d972924fa22f16d60852.webp"></p>
<p><img src="/../images/HashMap/38df956bd67a2da550ba658d221286a5.webp"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/26/%E6%95%B0%E7%BB%84%E5%92%8C%E9%93%BE%E8%A1%A8%E7%9A%84%E5%8C%BA%E5%88%AB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="xiaozhigang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xiaozhigang">
      <meta itemprop="description" content="最后不知天在水，满船清梦压星河。">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | xiaozhigang">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/04/26/%E6%95%B0%E7%BB%84%E5%92%8C%E9%93%BE%E8%A1%A8%E7%9A%84%E5%8C%BA%E5%88%AB/" class="post-title-link" itemprop="url">数组和链表的区别</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-04-26 22:06:29" itemprop="dateCreated datePublished" datetime="2022-04-26T22:06:29+08:00">2022-04-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JAVA/" itemprop="url" rel="index"><span itemprop="name">JAVA</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>虽然网上已经有很多了，但是我还是尝试总结一下，添加一点自己的心得。</p>
<p>总体来说，数组和链表是两种数据结构，所有的异同都是这两种数据结构的特点导致的。这两种数宝结构是计算机的基本数据结构，基态所有都是基于这两种数据结构实现的，只不过在细节上有区别。</p>
<h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>数组：多用于读多写少的情况，读取O(1)，写入O(n)，修改O(1)，删除O(n)；需要连续内存。</p>
<p>链表：多用于读少写多的情况，读取O(n)，写入O(1)，修改O(n)，删除O(1)；不需要连续内存。</p>
<h2 id="数据结构差异"><a href="#数据结构差异" class="headerlink" title="数据结构差异"></a>数据结构差异</h2><p>​        从下图很明显就能看出两者的差别。数组需要连续，即连在一起，而链表不需要，只需要有个指针指向下一个。但是这个指向下一个的指针，也需要占用内存，导致链表中的单个元素比数组中的一个元素的内存大。</p>
<p><img src="/../images/java-link/image-20240326230530963.png" alt="image-20240326230530963"></p>
<h2 id="增删改查的效率差异"><a href="#增删改查的效率差异" class="headerlink" title="增删改查的效率差异"></a>增删改查的效率差异</h2><p>上面的数据结构差异，不可避免的导致了读写性能的差异。</p>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>就像把人都聚集在一起，排好大小个顺序放在一个房间(连续内存)里。</p>
<pre><code>查：一般我们查，都是按下标去查数组里的元素，也就相当于知道按大小顺序排的第多少个，直接找到就行。O(1)

改：既然我们能查到某个元素，改的话就是换掉这个元素。就相当于找到某个位置的人，把这个人换掉，一个位置换个人而已。O(1)

增：这时候你需要增加一个人（元素）进来，找到位置，这时候这位置上原本是有人（元素）的，那现在插入的人（元素）来了，这位置和后面位置的人都要向后移一位。   O(n)

删：这刚好和上面的增操作是相反操作。找到合适位置后，踢出这个人（元素），后面位置上的人（元素）都要前进一位。O(n)
</code></pre>
<h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p> 就像我们把一个一个人分开，他们每个人只知道排在自己后面的人在什么位置(也可以知道前一个人)，类似于手拉手排队一样。</p>
<pre><code>查：这时候没有具体位置给我们，因为我们也不知道每个人（元素）的具体位置。只是因为大家手拉手（指针）的原因，前一个人能找到排在他后面位置的人。那我们找一个人的时候，就需要每个人都问一边，问一下是不是我们要找的人，不是的话再找下一个，直至找到或者找完。O(n)

改：和上面相同，既然能找到，就能换掉，只不过这次换有点特殊。每个人都是手拉手（指针），我们换掉之后要保证他们还是手拉手（指针）。O(n)

增：这时候你需要增加一个人（元素）进来，找到位置，这时候这位置上原本是有人（元素）的，后面的位置也可能是有人（元素）的，此时我们不要移动后面的人，只需要前后位置人的手牵到的是新增人员（元素）的手行，这样就减少了移动的操作。O(1)

删：这刚好和上面的增操作是相反操作。找到合适位置后，踢出这个人（元素），这位置前后面位置上的人（元素）手拉手就行。O(1)
</code></pre>
<p><img src="/../images/java-link/d16999981a659815687de65c2c060f35.webp" alt="img"></p>
<h2 id="空间差异"><a href="#空间差异" class="headerlink" title="空间差异"></a>空间差异</h2><h3 id="数组-1"><a href="#数组-1" class="headerlink" title="数组"></a>数组</h3><p>上面也说到了，数组就像把人都聚集在一起，排好大小个顺序放在一个房间(连续内存)里，那对房子的要求就比较高，需要有足够大的房子。如果新增一人，房间（连续内存）不够大了，那所有的人都要换一个大一点的房子进去按顺序排着。这样就不利于扩展，大家都知道大房子（连续内存）是稀缺资源。</p>
<h3 id="链表-1"><a href="#链表-1" class="headerlink" title="链表"></a>链表</h3><p>而链表就比较友好了，有块空地(内存)就行，因为不需要房子(连续内存)，这样对于空间(内存)利用率就比较高，能把所有没有房子(非连续内存)的地方都用上，这样就比较适合添加人。</p>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>其实计算机的所有底层内存逻辑基本都按这个连续和不连续的模式来的。比如二叉树这种数据结构，说白了也就是链表的一种变种，由链表的指向下一个变成指向下两个。</p>
<p>除此之外，在jvm底层的垃圾回收，基本也是按照这种套路，新老代的垃圾回收，各种回收算法。比如标记清理、标记整理。</p>
<p>标记清理: 只是把内存中无效的对象删掉，可以想象，一块内存中，其中有的对象被删了有的没删，这就导致这部分内存可用性就低，因为内存被没删的内存分隔成一小段一小段的，不是连续的。虽然空间利用率不高，但是这种办法简单，只要删掉无效的对象就行。</p>
<p>标记整理: 算法的前部分和标记-清理算法一样，将无效对象删掉，但是资格算法还有后续，将剩余的对象整理一起，放在内存的一端，这样空出的内存就又连续上了。这种算法对空间的利用率就比较好，但是比较麻烦，毕竟要整理嘛。</p>
<p><img src="/../images/java-link/cf72233c16942487ce3bd3f0d82b4652.webp" alt="img"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/10/%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="xiaozhigang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xiaozhigang">
      <meta itemprop="description" content="最后不知天在水，满船清梦压星河。">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | xiaozhigang">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/04/10/%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">约瑟夫环问题</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-04-10 21:12:11" itemprop="dateCreated datePublished" datetime="2022-04-10T21:12:11+08:00">2022-04-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="约瑟夫斯问题"><a href="#约瑟夫斯问题" class="headerlink" title="约瑟夫斯问题"></a>约瑟夫斯问题</h1><p>有时也称为约瑟夫斯置换，是一个出现在计算机科学和数学中的问题。在计算机编程的算法中，类似问题又称为约瑟夫环。<br>人们站在一个等待被处决的圈子里。 计数从圆圈中的指定点开始，并沿指定方向围绕圆圈进行。 在跳过指定数量的人之后，执行下一个人。 对剩下的人重复该过程，从下一个人开始，朝同一方向跳过相同数量的人，直到只剩下一个人，并被释放。<br>问题即，给定人数、起点、方向和要跳过的数字，选择初始圆圈中的位置以避免被处决。</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>有n个人编号，站成一圈：<br>1  2  3  4 … … n-1  n</p>
<p>现在从1开始进行报数，报到k的出列自杀，然后剩下的人继续从1报数（当到达编号为n的人时，下一个报数的从编号为1的人开始进行）：<br>1  2  3  4… k(出列自杀)  1  2  …</p>
<p>直到圈内只剩余m人，求胜利者的编号。<br>例如：当n&#x3D;6, k&#x3D;5, m&#x3D;1时，5,4,6,2,3将会被依次处决，而1将会幸免。</p>
<p>示例代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">public class JosephProblem &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 返回活着的人的位置</span><br><span class="line">     *</span><br><span class="line">     * @param total 总人数</span><br><span class="line">     * @param magicNum 报数到该数字的人自杀</span><br><span class="line">     * @param remain 笑着活下去的人</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    private List getJosephNumbers(int total, int magicNum, int remain) &#123;</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; peopleList = new ArrayList&lt;&gt;();</span><br><span class="line">        for (int i = 1; i &lt;= total; i++) &#123;</span><br><span class="line">            peopleList.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; diedList = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        int index = -1;  //当前应该删除的位置</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            index = (index + magicNum) % peopleList.size();</span><br><span class="line"></span><br><span class="line">            diedList.add(peopleList.get(index));</span><br><span class="line">            peopleList.remove(index);</span><br><span class="line"></span><br><span class="line">            //从上一个位置开始计数</span><br><span class="line">            index--;</span><br><span class="line"></span><br><span class="line">            //判断是否剩余m个，如果是的话结束</span><br><span class="line">            if (peopleList.size() == remain) &#123;</span><br><span class="line">                System.out.println(&quot;共&quot; + total + &quot;人，依次报数，当报到&quot; + magicNum + &quot;的人自杀，&quot; + remain + &quot;个人笑着活下去.&quot;);</span><br><span class="line">                System.out.println(&quot;死掉的序号顺序为：&quot; + diedList);</span><br><span class="line">                System.out.println(&quot;笑着活下去序号为：&quot; + peopleList);</span><br><span class="line">                System.out.println(&quot;----------------------------------&quot;);</span><br><span class="line">                return peopleList;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        JosephProblem test = new JosephProblem();</span><br><span class="line"></span><br><span class="line">        test.getJosephNumbers(10, 4, 1);</span><br><span class="line">        test.getJosephNumbers(10, 2, 1);</span><br><span class="line">        test.getJosephNumbers(10, 3, 1);</span><br><span class="line">        test.getJosephNumbers(20, 10, 3);</span><br><span class="line">        test.getJosephNumbers(20, 4, 6);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">共10人，依次报数，当报到4的人自杀，1个人笑着活下去.</span><br><span class="line">死掉的序号顺序为：[4, 8, 2, 7, 3, 10, 9, 1, 6]</span><br><span class="line">笑着活下去序号为：[5]</span><br><span class="line">----------------------------------</span><br><span class="line">共10人，依次报数，当报到2的人自杀，1个人笑着活下去.</span><br><span class="line">死掉的序号顺序为：[2, 4, 6, 8, 10, 3, 7, 1, 9]</span><br><span class="line">笑着活下去序号为：[5]</span><br><span class="line">----------------------------------</span><br><span class="line">共10人，依次报数，当报到3的人自杀，1个人笑着活下去.</span><br><span class="line">死掉的序号顺序为：[3, 6, 9, 2, 7, 1, 8, 5, 10]</span><br><span class="line">笑着活下去序号为：[4]</span><br><span class="line">----------------------------------</span><br><span class="line">共20人，依次报数，当报到10的人自杀，3个人笑着活下去.</span><br><span class="line">死掉的序号顺序为：[10, 20, 11, 2, 14, 6, 19, 15, 9, 7, 5, 8, 13, 18, 12, 4, 17]</span><br><span class="line">笑着活下去序号为：[1, 3, 16]</span><br><span class="line">----------------------------------</span><br><span class="line">共20人，依次报数，当报到4的人自杀，6个人笑着活下去.</span><br><span class="line">死掉的序号顺序为：[4, 8, 12, 16, 20, 5, 10, 15, 1, 7, 14, 2, 11, 19]</span><br><span class="line">笑着活下去序号为：[3, 6, 9, 13, 17, 18]</span><br><span class="line">----------------------------------</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/page/3/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/5/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 2022 – 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">xiaozhigang</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>


    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>


  <script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"default","dark":"dark"},"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mermaid/10.7.0/mermaid.min.js","integrity":"sha256-TtLOdUA8mstPoO6sGvHIGx2ceXrrX4KgIItO06XOn8A="}}</script>
  <script src="/js/third-party/tags/mermaid.js"></script>





  





</body>
</html>
