<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" integrity="sha256-wiz7ZSCn/btzhjKDQBms9Hx4sSeUYsDrTLg7roPstac=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.19.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="最后不知天在水，满船清梦压星河。">
<meta property="og:type" content="website">
<meta property="og:title" content="xiaozhigang">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="xiaozhigang">
<meta property="og:description" content="最后不知天在水，满船清梦压星河。">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="xiaozhigang">
<meta property="article:tag" content="java,中间件，后端，大数据，ai">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/page/2/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/2/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>xiaozhigang</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">xiaozhigang</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">长风破浪会有时，直挂云帆济沧海。</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">xiaozhigang</p>
  <div class="site-description" itemprop="description">最后不知天在水，满船清梦压星河。</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">45</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">34</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/04/18/%E7%9F%A5%E8%AF%86%E5%BA%93%E6%9E%B6%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="xiaozhigang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xiaozhigang">
      <meta itemprop="description" content="最后不知天在水，满船清梦压星河。">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | xiaozhigang">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/04/18/%E7%9F%A5%E8%AF%86%E5%BA%93%E6%9E%B6%E6%9E%84/" class="post-title-link" itemprop="url">知识库原理</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-04-18 22:28:27" itemprop="dateCreated datePublished" datetime="2024-04-18T22:28:27+08:00">2024-04-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/AI/" itemprop="url" rel="index"><span itemprop="name">AI</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>现在大模型大行其道，我们普通人没有那么多资源，有没有办法搭建一个大模型玩一下呢，答案肯定是有的，我们可以搭建一个知识库，用一下大模型。</p>
<p>总所周知，大模型的训练是需要大量资源的，我们没有这么多资源，那我们就得想办法绕过训练或者减少训练。这时候知识库就是一个比较好的选择，它不需要对大模型进行大量的训练，大模型只是帮我们生成一个类人话的答案。</p>
<h3 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h3><p>目前比较用的比较多的就是LangChain框架，这是一种基于Langchain 与 ChatGLM 等大语言模型的本地知识库问答应用实现。</p>
<p><img src="/../images/LangChain/langchain+chatglm.png"></p>
<p>可以从上面的原理图看出知识库的整个实现原理。</p>
<p>1、先加载文件，文件可以是结构化的也可以是非结构化的</p>
<p>2、读取文本，这就很好理解了，将加载进来的文件读取</p>
<p>3、分割文本，将读取的文本分割成一段一段的，便于提取其中的关键字和让内容更内敛</p>
<p>4、向量化，将分割后的文本向量化，</p>
<p>5、存储，将向量化后的文本存入向量数据库中，当然可能也有一些结构型数据，直接存入关系型数据库中</p>
<p>6、问句向量化，将我们提问的问句给向量化，理论上和上面的文本向量化一样，问句也是一个文本</p>
<p>7、向量化匹配，通过问句的向量去向量库里面匹配文本，可能会匹配出多个，我们只取top n</p>
<p>8、生成prompt，将匹配到的文本作为上下文和问题一起生成prompt</p>
<p>9、将prompt提交给LLM生成回答</p>
<p>上面就是知识库的原理和流程。可以看到，其实大模型在这里只是扮演一个类人化回答生成的作用，回答中的知识点其实都是在向量化匹配的过程中匹配出来的。所以这里不需要大模型做大量的训练。</p>
<p>LangChain只是做了一个框架，上面的原理和流程也只是一个大纲，具体的细节我们还是有很多可操控空间的。</p>
<p>比如说文本分割，框架提供的默认分割方法是分割到什么程度，我们需要的又是分割到什么程度，如果框架提供的分割粒度比较答，一篇文章分割之后，分割成了几个大段，我们后面匹配到了，一起放到大模型中生成回答也是一个巨大的计算量或者有些大模型都不支持，文本大了，相当于参数就多了，那生成回答的计算量就变大了，甚至有些参数都支持不了这么多参数。</p>
<p>在比如说，在向量匹配的过程中，我们只能使用框架提供的匹配方法嘛，当然不是，毕竟框架不可能面面俱到，我们可能要做一些权重微调，或者换一种算法，再或者有的时候需要我们去关系型数据库中匹配。</p>
<p>最后，既然大模型只是一个生成类人回答的作用，那我们是不是就可以把LLM就是一个接口，其中具体是什么大模型，我们不是特别关注，毕竟只要能给我们根据知识点生成一段通顺的回答就行，至于是LangChain还是chatGLM，又或者是阿里清华的大模型，我们都不是特别关注。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/04/18/%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="xiaozhigang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xiaozhigang">
      <meta itemprop="description" content="最后不知天在水，满船清梦压星河。">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | xiaozhigang">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/04/18/%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">配置中心分析</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-04-18 20:33:29" itemprop="dateCreated datePublished" datetime="2024-04-18T20:33:29+08:00">2024-04-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Spring/" itemprop="url" rel="index"><span itemprop="name">Spring</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>配置中心可以兼顾<strong>配置实时性、配置的流程管理、以及分布式场景</strong>的应用。</p>
<p>配置实时性：传统的静态配置方式想要修改某个配置，则需要修改后重启，如果想要实现动态修改，可以使用数据库，采用轮询的方式，访问数据库获得配置数据。轮询频率低的话对配置数据变更的感知就慢，频率高的话，就会消耗过多的性能。</p>
<p>配置管理流程：权限管理、灰度管理、版本管理、格式检验和安全配置</p>
<p>分布式场景：随着采用分布式开发模式，项目之间的相互引用不断增多，相互之间的调用复杂度也指数上升，需要配置中心治理。</p>
<h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><p><strong>灰度发布</strong>：当配置修改影响较大时，需要先在部分实例中生效，验证配置变更符合预期之后再推送到所有实例。</p>
<p><strong>权限管理</strong>：对配置变更的权限管控，以及对审计权限的管控</p>
<p><strong>版本管理&amp;回滚</strong>：当配置变更不符合预期时，需要根据配置发布版本回滚</p>
<p><strong>配置格式校验</strong>：配置数据一般会以一种配置格式存储，配置中心会对配置数据的格式进行校验，防止格式错误导致的各种问题</p>
<p><strong>监听查询</strong>：当排查问题或者进行统计的时候，需要指导一个配置被哪些实例使用到，以及一个实例使用了哪些配置</p>
<p><strong>多环境</strong>：生产环境中，配置中心常常需要涉及到多环境或者多集群，业务在开发环境和生产环境隔离开，或者根据不同的生产线存在多个生产环境，各环境隔离之后相互影响就小。</p>
<p><strong>多集群</strong>：当对稳定性要求比较高，不允许各个环境相互影响的时候，需要将多环境通过多集群的方式进行物理隔离</p>
<h3 id="常用配置中心"><a href="#常用配置中心" class="headerlink" title="常用配置中心"></a>常用配置中心</h3><h4 id="Apollo"><a href="#Apollo" class="headerlink" title="Apollo"></a>Apollo</h4><p><img src="/../images/spring-config/overall-architecture.png"></p>
<h4 id="spring-cloud-config"><a href="#spring-cloud-config" class="headerlink" title="spring cloud config"></a>spring cloud config</h4><p><img src="/../images/spring-config/a3bb80c142c74634aa8ed67e8bf1ac3d.png" alt="overall-architecture"></p>
<h4 id="nacos"><a href="#nacos" class="headerlink" title="nacos"></a>nacos</h4><p><img src="/../images/spring-config/1561217892717-1418fb9b-7faa-4324-87b9-f1740329f564.jpeg" alt="nacos_arch.jpg"></p>
<h4 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h4><table>
<thead>
<tr>
<th></th>
<th>spring cloud config</th>
<th>Apollo</th>
<th>nacos</th>
</tr>
</thead>
<tbody><tr>
<td>配置界面</td>
<td>不支持</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>配置实时推送</td>
<td>支持（spring cloud bus）</td>
<td>支持（http长轮询）</td>
<td>支持（http长轮询）</td>
</tr>
<tr>
<td>版本管理</td>
<td>支持（git）</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>配置回滚</td>
<td>支持（git）</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>灰度发布</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>权限管理</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>多集群</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>多环境</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>监听查询</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>多语言</td>
<td>java</td>
<td>多语言</td>
<td>多语言</td>
</tr>
<tr>
<td>配置格式校验</td>
<td>不支持</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>分布式部署</td>
<td>复杂</td>
<td>复杂</td>
<td>简单</td>
</tr>
<tr>
<td>数据一致性</td>
<td>git保证数据一致性，config service从git读取数据</td>
<td>数据量模拟消息队列，Apollo定时读取消息队列</td>
<td>http异步通知</td>
</tr>
<tr>
<td>通信协议</td>
<td>http、amqp</td>
<td>http</td>
<td>http</td>
</tr>
</tbody></table>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/04/16/%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="xiaozhigang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xiaozhigang">
      <meta itemprop="description" content="最后不知天在水，满船清梦压星河。">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | xiaozhigang">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/04/16/%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">注册中心分析</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-04-16 19:25:11" itemprop="dateCreated datePublished" datetime="2024-04-16T19:25:11+08:00">2024-04-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Spring/" itemprop="url" rel="index"><span itemprop="name">Spring</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h3><p>之前面试问到了工作中用到的注册中心和市面上的有啥异同。</p>
<p>公司用的注册中心：Zookeeper</p>
<p>市面上除此之外还有其他注册中心：Eureka、Consul、Nacos</p>
<table>
<thead>
<tr>
<th>组件名称</th>
<th>所属公司</th>
<th>组件介绍</th>
</tr>
</thead>
<tbody><tr>
<td>Zookeeper</td>
<td>Apache</td>
<td>Zookeeper是一个分布式协调工具，可以实现注册功能</td>
</tr>
<tr>
<td>Eureka</td>
<td>Netflix</td>
<td>Spring最早的注册中心，目前已经进入停更进维</td>
</tr>
<tr>
<td>Consul</td>
<td>Hashicorp</td>
<td>Consul简化了分布式环境中的服务的注册和发现流程，通过HTTP或者DNS接口发现，支持外部Saas提供者等</td>
</tr>
<tr>
<td>Nacos</td>
<td>Alibaba</td>
<td>Nacos致力于发现、配置和管理微服务。Nacos提供了一组简单易用的特性集，快速实现动态服务发现、服务配置、服务元数据以及流量管理</td>
</tr>
</tbody></table>
<h3 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a>Zookeeper</h3><p>遵循CP原则（一致性，分区容错性），牺牲了高可用。所以任何时候请求都能得到一致的数据结果，但是不能保证每次服务请求都是可达的。比如请求的时候leader节点宕机，或者集群中半数以上节点不可用，那么将无法处理请求。</p>
<h3 id="Eureka"><a href="#Eureka" class="headerlink" title="Eureka"></a>Eureka</h3><p>遵循AP原则（可用性，分区容错性），牺牲了数据一致性。也就是能保证每次服务请求都是可达的，但是不能保证每次的请求结果都是一致的。Eureka集群没有主从之分，采用的是Peer to Peer对等通信，这是一种去中心化的架构，每个节点都需要添加一个或多个有效的serviceUrl指向其他节点，每个节点都是其他节点的副本。集群中只要还有一个节点存活，那么服务就是可用的，但是不饿能保证查到的数据是最新的或者一致的。</p>
<p>除此之外还有一种保护机制，如果在15分钟内超过85%的节点都没有正常心跳，Eureka则认为客户端与注册中心之间出现了网络故障，此时会出现以下几种情况：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1、Eureka不再从注册表中移除因长时间没有收到心跳而过期的服务</span><br><span class="line"></span><br><span class="line">2、Eureka仍然能够接受新服务注册和查询请求，但不会同步到其他节点上，只保证当前节点可用</span><br><span class="line"></span><br><span class="line">3、当网络稳定时，当前实例新注册的信息会被同步到其他节点</span><br></pre></td></tr></table></figure>



<h3 id="Consul"><a href="#Consul" class="headerlink" title="Consul"></a>Consul</h3><p>遵循CP原则，Hashicorp公司开发，用于实现分布式系统的服务发现与配置。使用的时Raft算法，比zookeeper使用的Paxos算法更简单，虽然保证了强一致性，但是可用性方面性能有所下降，比如在服务注册方面，Raft协议要求半数以上的节点都写入才算注册成功，leader节点宕机之后，在重新选取出leader节点之前都会导致不可用。</p>
<h3 id="Nacos"><a href="#Nacos" class="headerlink" title="Nacos"></a>Nacos</h3><p>遵循AP原则，也可支持CP原则，阿里开源，nacos &#x3D; 注册中心 + 配置中心，总之很强大，推荐。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><table>
<thead>
<tr>
<th></th>
<th>Nacos</th>
<th>Eureka</th>
<th>Consul</th>
<th>Zookeeper</th>
</tr>
</thead>
<tbody><tr>
<td>一致性协议</td>
<td>CP+AP</td>
<td>AP</td>
<td>AP</td>
<td>CP</td>
</tr>
<tr>
<td>健康检查</td>
<td>TCP&#x2F;HTTP&#x2F;MySQL&#x2F;Client Beat</td>
<td>Client Beat</td>
<td>TCP&#x2F;HTTP&#x2F;gRPC&#x2F;Cmd</td>
<td>keep alive</td>
</tr>
<tr>
<td>负载均衡</td>
<td>权重&#x2F;metadata&#x2F;Selector</td>
<td>Ribbon</td>
<td>Fabio</td>
<td>-</td>
</tr>
<tr>
<td>自动注销实例</td>
<td>支持</td>
<td>支持</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>访问协议</td>
<td>HTTP&#x2F;DNS</td>
<td>HTTP</td>
<td>HTTP&#x2F;DNS</td>
<td>TCP</td>
</tr>
<tr>
<td>监听支持</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>多数据中心</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
<td>不支持</td>
</tr>
<tr>
<td>跨注册中心同步</td>
<td>支持</td>
<td>不支持</td>
<td>支持</td>
<td>不支持</td>
</tr>
<tr>
<td>SpringCloud集成</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
<td>不支持</td>
</tr>
</tbody></table>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/04/15/4%E6%9C%8815%E9%9D%A2%E8%AF%95%E5%A4%8D%E7%9B%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="xiaozhigang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xiaozhigang">
      <meta itemprop="description" content="最后不知天在水，满船清梦压星河。">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | xiaozhigang">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/04/15/4%E6%9C%8815%E9%9D%A2%E8%AF%95%E5%A4%8D%E7%9B%98/" class="post-title-link" itemprop="url">4月15面试复盘</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-04-15 21:14:54" itemprop="dateCreated datePublished" datetime="2024-04-15T21:14:54+08:00">2024-04-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">面试</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h3><p>今天面试了两个，一个下午，一个晚上，下午面试没有聊的很深，貌似很着急招人的样子，晚上聊了很久，更类似于聊天探讨形式。</p>
<h3 id="面试问题"><a href="#面试问题" class="headerlink" title="面试问题"></a>面试问题</h3><p>有些问题记不上来了，将记忆清楚和答的不好的记录复盘。</p>
<h4 id="问题1"><a href="#问题1" class="headerlink" title="问题1"></a>问题1</h4><p>问：</p>
<p>我们使用的<strong>注册中心、配置中心</strong>和市面使用的spring或者nacos的异同。</p>
<p>复盘：</p>
<p>公司使用的是zookeeper，市面常见的主要有4种<strong>Eureka、Zookeeper、Consul、Nacos</strong>。</p>
<p>具体的对比差异没有答好，简述了注册中心<strong>AP，CP</strong>的差异。</p>
<p>在配置中心上，目前常用的有<strong>springcloud config、nacos、apollo</strong></p>
<p>具体的差异也没答上。</p>
<p>后续整理归纳一篇文章。</p>
<h4 id="问题2"><a href="#问题2" class="headerlink" title="问题2"></a>问题2</h4><p>问：自定义经典线程池拒绝策略</p>
<p>复盘：</p>
<p>相当于知识盲区了，没有答上，只知道有4种拒绝策略：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1、AbortPolicy：默认拒绝策略，抛出RejectExecutionException异常</span><br><span class="line"></span><br><span class="line">2、CallerRunsPolicy：不抛异常，而是让提交任务的线程自己去执行这个任务</span><br><span class="line"></span><br><span class="line">3、DiscardOldestPolicy：策略会丢失队列中最老的以恶搞任务，然后重新尝试新提交被拒绝的任务</span><br><span class="line"></span><br><span class="line">4、DiscardPolicy：抛弃被拒绝的任务，不会做任何处理也不会抛出异常。</span><br></pre></td></tr></table></figure>

<p>自定义的拒绝策略没有了解过，可以写篇文章总结了解一下。</p>
<h4 id="问题3"><a href="#问题3" class="headerlink" title="问题3"></a>问题3</h4><p>问：优化SQL方案</p>
<p>复盘：知道一些优化方案，但是没有条理性</p>
<p>需要整理一下，最好整理成一个全面的方法论</p>
<h4 id="问题4"><a href="#问题4" class="headerlink" title="问题4"></a>问题4</h4><p>问：redis和数据库同步一致性方案</p>
<p>复盘：知道新跟新数据库，再更新缓存</p>
<p>但是全面的方法论没有将出来。</p>
<h4 id="问题5"><a href="#问题5" class="headerlink" title="问题5"></a>问题5</h4><p>问：jdk 虚拟线程，新版jdk特性</p>
<p>复盘：jdk8之后都没有了解，这块短板等补齐，目前面试很少问到这个，但是得了解补齐.</p>
<p>问：新版jdk的垃圾回收器</p>
<p>复盘：同上</p>
<h4 id="问题6"><a href="#问题6" class="headerlink" title="问题6"></a>问题6</h4><p>问：jdk调优工具</p>
<p>复盘：知识盲点。得补齐，可能后续面试工作中用不到，但是得了解一下。</p>
<h4 id="问题7"><a href="#问题7" class="headerlink" title="问题7"></a>问题7</h4><p>问：如何打破双亲加载机制</p>
<p>复盘：知道双亲加载机制，但是如何打破倒是没有深入了解，自己也写篇文章总结一下。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>总体来说，每个问题都有自己知道的点，但是好多没有全面的回答。<strong>回答的都是一个个的点，没有梳理成一个面</strong>，体现自己的逻辑性，条理性和全面性</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/03/27/%E9%9D%A2%E8%AF%95%E5%A4%8D%E7%9B%98-03-27/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="xiaozhigang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xiaozhigang">
      <meta itemprop="description" content="最后不知天在水，满船清梦压星河。">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | xiaozhigang">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/03/27/%E9%9D%A2%E8%AF%95%E5%A4%8D%E7%9B%98-03-27/" class="post-title-link" itemprop="url">面试复盘-03-27</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-03-27 18:39:52" itemprop="dateCreated datePublished" datetime="2024-03-27T18:39:52+08:00">2024-03-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-03-28 21:09:36" itemprop="dateModified" datetime="2024-03-28T21:09:36+08:00">2024-03-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">面试</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>这次面试场面有点大，6个面试官，但只有3个面试官提问了。前两个面试官回答的还行，后一个面试官直接问懵了。</p>
<h2 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h2><p>19年毕业，4年多工作经验，华为这边工作。</p>
<p>目前团队业务是以洞察、评估、规划和收益四个部分向运营商提供数字化机会点发现。</p>
<p>项目是以全球数据沙盘项目为基础，业务向外扩展OTN to 楼宇，OTN综合承载等项目。</p>
<p>自己近项目组以来，从构建测试网络开始了解全球数据沙盘项目，到路网算法开始参与项目，然后开始OTN to 楼宇参与业务拓展，到最后的模型收编和原子能力编排重构项目。</p>
<h4 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h4><p>可以说一下自己参与<strong>开源项目dubbo</strong>，个人学习构建<strong>商城项目</strong>的框架代码，以及个人<strong>博客文章</strong>的分享。</p>
<p>也可以说一下自己在团队内的定位。</p>
<p>可以画个<strong>思维导图</strong>，下次按思维导图介绍。</p>
<p><img src="/../images/black-03-27/image-20240328200205037.png"></p>
<h2 id="第一个面试官"><a href="#第一个面试官" class="headerlink" title="第一个面试官"></a>第一个面试官</h2><h3 id="MySQL索引"><a href="#MySQL索引" class="headerlink" title="MySQL索引"></a>MySQL索引</h3><p>问：简述一下mysql的索引</p>
<p>答：索引类似于书的目录，加快查找数据，它的存在空间换时间。空间就不用说了，索引的存在必然消耗空间，时间的话就是提高了查找效率，减少了消耗的时间。索引分为<strong>聚簇索引</strong>和<strong>非聚簇索引</strong>，以InnoDB而言，索引以B+数的形式存储，只不过聚簇和非聚簇在存储细节上有所不同。聚簇也就是主键索引，在叶子节点上是以主键和数据一起存放的，而非聚簇索引的叶子节点存储的是普通索引和主键。在查找数据的时候，如果是主键查询责直接通过B+数找到数据，非聚簇索引的话，要通过B+树先找到主键，在通过主键查到数据，这个过程叫做回表。为了提高查找的效率，所以我们一般在查询的时候尽量使用索引，且减少回表。</p>
<h4 id="回溯-1"><a href="#回溯-1" class="headerlink" title="回溯"></a>回溯</h4><p>点应该都答到了，感觉面试官还比较满意回答，具体的细节和描述的方法可以更提高一点，显得更有条理性。</p>
<p>总述：索引类似于书的目录，空间换时间，占用了磁盘空间，减少了查找时间。</p>
<p>分述：分<strong>聚簇索引</strong>和<strong>非聚簇索引</strong>，二者在存储上的差异（B+树叶节点的不同），在查询上的差异（回表）。以及我们在实际使用的时候需要注意的点（减少回表，最左覆盖，索引下推，等）。</p>
<p>追问：既然说到B+树，说一下10个节点的红黑树需要查询一个节点的时间消耗</p>
<p>答：时间复杂度O(ln)，红黑树的第一层是一个节点，第二层是2个节点，第三层是4个，第5层是8个。查询的话上来先比较根节点，如果比根节点大往右，否则往左…（简述了一下查询流程）…查询像二分查找，先找中间值，比大小等</p>
<h4 id="回溯-2"><a href="#回溯-2" class="headerlink" title="回溯"></a>回溯</h4><p>应该是面试官想听到的，现场感觉面试官比较满意，但是自己不是很清楚红黑树，不清楚红黑树的非叶子节点是否保存了数据，还是和B+树一样只做比较。</p>
<p>增加实际业务中的的案例，走联合索引的案例，调换where中的条件顺序。</p>
<h3 id="SpringMVC流程"><a href="#SpringMVC流程" class="headerlink" title="SpringMVC流程"></a>SpringMVC流程</h3><p>问：说一下MVC的查询流程</p>
<p>答：<strong>客户端</strong> 请求到 <strong>DispatcherServlet</strong>， <strong>DispatcherServlet</strong>到<strong>HandlerMapping</strong>，然后返回结果给<strong>DispatcherServlet</strong>，<strong>DispatcherServlet</strong>在将handler转发到适配器，适配器会有一些过滤拦截啥的，通过后到处理器，也就是controller-&gt;service-&gt;map，然后结果在原路返回到<strong>DispatcherServlet</strong>，<strong>DispatcherServlet</strong>在拿到结果后回去调用视图解析器啥的，去将返回的结果解析渲染。</p>
<h4 id="回溯-3"><a href="#回溯-3" class="headerlink" title="回溯"></a>回溯</h4><p>回答面试官比较满意，听其语义主要想听到<strong>DispatcherServlet</strong>，但是此流程中记得是在适配器中会有拦截过滤，不是特别确定，已经返回结果后的视图解析渲染，两个组件名称记得不是特别清楚。</p>
<p><img src="/../images/black-03-27/2474678-20221205141025926-329048743.png" alt="img"></p>
<h3 id="服务间通信"><a href="#服务间通信" class="headerlink" title="服务间通信"></a>服务间通信</h3><p>问：你们有多模块多服务吗，服务间的调用是用的什么。</p>
<p>答：有，上面自我介绍中也说到了，我们所有业务基本可以分为：洞察，评估，规划，收益，四个模块。模块间的调用用的是http请求。</p>
<p>追问：请求的结果是要转换的，你们是怎么转换的。</p>
<p>答：我们的请求不涉及到请求结果的转换，不是那种强依赖。我们模块间的数据交互都是放在数据库的，比如洞察处理完的数据会放在数据库，然后调用评估的模块开始处理，评估模块处理的时候会调用数据库的数据处理，处理的结果会放回数据库，而不是返回给评估模块，这样更解耦。</p>
<h4 id="回溯-4"><a href="#回溯-4" class="headerlink" title="回溯"></a>回溯</h4><p>其实对这请求调用的方式记得不是特别清楚了，需要复习回顾一下。</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/Andy19891117/article/details/134981402">https://blog.csdn.net/Andy19891117/article/details/134981402</a></p>
<p>RPC调用和http调用，RPC基于传输层TCP协议，Http基于应用层http协议，所以RPC调用的传输效率更高。Http规定了返回的格式而RPC没有。</p>
<h2 id="第二个面试官"><a href="#第二个面试官" class="headerlink" title="第二个面试官"></a>第二个面试官</h2><h3 id="jar包加载"><a href="#jar包加载" class="headerlink" title="jar包加载"></a>jar包加载</h3><p>问：简历中说的到的原子能力编排是怎么理解的，包是spring jar还是啥，编排是怎么理解。</p>
<p>答：jar包是fast jar，不是那种有启动类的可执行jar包，编排的话，是我们把能力抽取成一个个的jar包，再以可视化配置的方式，类似于链式调用。</p>
<p>追问：编排的结果，jar包的顺序执行，这个是以什么数据结构存储的。</p>
<p>答：存在数据库中，是以字符串的形式存储的，在读取到数据库中字符串，在以特定的字符将字符串分割开，然后遍历执行。</p>
<p>追问：前端是怎么配置调用后端的jar的</p>
<p>答：我们是按迭代内的业务需求配置上线的，前台只是提供一个可视化的界面供开发配置，其实我们更习惯直接在配置文件xml中配置，配置完的xml文件会提交到代码仓，在我们的部署阶段，会将这配置文件解析成字符串保存在数据库中，供读取。</p>
<p>追问：这个项目里的调度和引擎服务怎么理解。</p>
<p>答：这个网关，调度，引擎内容都比较简单，网关的话直接对外，调度只负责调用原子能力jar，引擎是加载运行jar。这么分是为了职责更单一内敛。</p>
<p>追问：jar包是怎么加载的。</p>
<p>答：读取到lib目录下的依赖，先将依赖通过双亲依赖加载给加载进来，然后在通过同一规范的jar包入口，开始调用jar内的方法。</p>
<p>追问：双亲加载有三个加载器，加载器是啥。</p>
<p>答：记得不是特别清了，只记得一个是系统加载，两个是加载外部文件依赖加载。</p>
<h4 id="回溯-5"><a href="#回溯-5" class="headerlink" title="回溯"></a>回溯</h4><p>面试感觉一般，虽然大部分都答到了，但是还有结果点不熟。</p>
<p>1、jar包的分类不熟</p>
<p>fat jar</p>
<p>2、jar包的加载，了解大概流程，不了解其具体细节。</p>
<p>3、三个父加载器忘了，没想起来名字。</p>
<p>4、怎么卸载jar包</p>
<p>启动类加载器（Bootstrap Class Loader）：也称为根类加载器，它负责加载Java虚拟机的核心类库，如java.lang.Object等。启动类加载器是虚拟机实现的一部分，它通常是由本地代码实现的，不是Java类。</p>
<p>扩展类加载器（Extension Class Loader）：它是用来加载Java扩展类库的类加载器。扩展类库包括javax和java.util等包，它们位于jre&#x2F;lib&#x2F;ext目录下。</p>
<p>应用程序类加载器（Application Class Loader）：也称为系统类加载器，它负责加载应用程序的类。它会搜索应用程序的类路径（包括用户定义的类路径和系统类路径），并加载类文件。</p>
<h3 id="注解加载"><a href="#注解加载" class="headerlink" title="注解加载"></a>注解加载</h3><p>问：注解是怎么加载的</p>
<p>答：看过源码，记得不是特别清了，spring启动类上会有enable开启注解加载，后面通过一层层的调用，大概3~4层，读取到lib目录下的文件，然后再通过条件判断是否加载。</p>
<h4 id="回溯-6"><a href="#回溯-6" class="headerlink" title="回溯"></a>回溯</h4><p>回答一般，之前确实看过，现在确实忘了</p>
<p><strong>自动配置原理</strong>：SpringBoot 项目的核心注解 @SpringBootApplication，这个注解位于启动类上方。@SpringBootApplication 看作是 @Configuration、@EnableAutoConfiguration、@ComponentScan 注解的集合。自动装配核心功能的实现是通过@EnableAutoConfiguration内部的AutoConfigurationImportSelector类。AutoConfigurationImportSelector 类实现了 ImportSelector 接口，也就实现了这个接口中的 selectImports 方法，<strong>该方法主要用于获取所有符合条件的类的全限定类名，需要为这些类创建对象并加载到 IoC 容器中</strong>。@ConditionOnXXX 中的所有条件都满足，该类才会生效</p>
<p>​	@EnableAutoConfiguration：启用 SpringBoot 的自动配置机制。</p>
<p>​	@Configuration：允许在上下文中注册额外的 bean 或导入其他配置类，作用与 applicationContext.xml 的功能相同。</p>
<p>​	@ComponentScan： 扫描包下的类中添加了@Component (@Service，@Controller，@Repostory，@RestController)注解的类 ，并添加的到spring的容器中，可以自定义不扫描某些 bean。</p>
<p><img src="/../images/black-03-27/image-20240329210812763.png" alt="image-20240329210812763"></p>
<p>getAutoConfigurationEntry：</p>
<p><strong>第 1 步：</strong>判断自动装配开关是否打开。默认 spring.boot.enableautoconfiguration &#x3D; true，可在 application.properties 或 application.yml 中设置</p>
<p><strong>第 2 步：</strong>用于获取 EnableAutoConfiguration 注解中的 exclude 和 excludeName。</p>
<p><strong>第 3 步：</strong>从 META-INF&#x2F;spring.factories 读取需要自动装配的所有配置类。</p>
<p><strong>第 4 步：</strong>这一步有经历了一遍筛选过滤，@ConditionOnXXX 中的所有条件都满足，该类才会生效</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_59749089/article/details/131280769">https://blog.csdn.net/m0_59749089/article/details/131280769</a></p>
<h2 id="第三个面试官"><a href="#第三个面试官" class="headerlink" title="第三个面试官"></a>第三个面试官</h2><h3 id="bean加载"><a href="#bean加载" class="headerlink" title="bean加载"></a>bean加载</h3><p>问：如果我想再bean初始化时候改变其变量值，或者说再方法前打印一个日志。</p>
<p>答：使用代理，再调用方法前后打印日志。</p>
<p>追问：不是代理，是在初始化的时候。</p>
<p>答：在xml文件中，配置修改，在bean初始化的时候给其赋值。</p>
<h4 id="回溯-7"><a href="#回溯-7" class="headerlink" title="回溯"></a>回溯</h4><p>貌似这也不是面试官想要的，确实不知道是啥，得查资料研究看看。</p>
<p>bean的加载过程：</p>
<p>加载bean信息–&gt;实例化bean–&gt;属性填充–&gt;初始化阶段–&gt;后置处理</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_46897923/article/details/129850717">https://blog.csdn.net/m0_46897923/article/details/129850717</a></p>
<h3 id="容器化"><a href="#容器化" class="headerlink" title="容器化"></a>容器化</h3><p>问：你们容器化用的怎么样。</p>
<p>答：我们部门目前才开始推，我们还没有开始使用容器化，但是自己也搭环境简单使用过容器化，比如部署一个redis、mysql等。</p>
<h4 id="回溯-8"><a href="#回溯-8" class="headerlink" title="回溯"></a>回溯</h4><p>熟悉了解一下容器化，这方面得了解确实不够，只是简单得使用了一下。</p>
<h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><p>问：核心线程数10，最大线程数20，现有1w个并发，为什么线程数一直是10，不是队列里有1w。</p>
<p>答：不知，尝试分析，是不是资源不够，没办法新增。</p>
<h4 id="回溯-9"><a href="#回溯-9" class="headerlink" title="回溯"></a>回溯</h4><p>确实不知，等了解。</p>
<p>问：synchronized的用法</p>
<p>答：修饰代码块或者方法，注意synchronized()中括号内的内容，可以是变量，对象和class类，对应锁的颗粒不一样。</p>
<p>追问：对象和class类有什么不一样。</p>
<p>答：对象是可以重复new的，但是class类只有一个，跟静态变量一样，用的时候要注意，别用错导致没锁好。</p>
<p>追问：线程的睡眠和唤醒是怎么样的。</p>
<p>答：A、B两个线程，A运行到某个地方，停住了睡眠了，B开始运行，运行到某个地方，通过A的方法唤醒A。</p>
<h4 id="回溯-10"><a href="#回溯-10" class="headerlink" title="回溯"></a>回溯</h4><p>1、感觉追问的对象和类有什么不一样，没回答到他想要的，复习一下。</p>
<p>2、睡眠唤醒的模型有点忘了，再代码实操一下。</p>
<h3 id="kafka"><a href="#kafka" class="headerlink" title="kafka"></a>kafka</h3><p>问：kafka里的消费者组是什么。</p>
<p>答：消费者的集合，一堆消费者组成的一个集合。</p>
<p>问：topic里的分区能被消费者组内的多个消费者消费吗</p>
<p>答：不能，一个分区只能被消费者组内一个消费者消费。</p>
<p>问：怎么保证生产者生产的消息，顺序消费。</p>
<p>答：都放在一个分区内，kafka不保证topic内的消息是顺序的，但是保证分区内的数据是顺序消费的。</p>
<p>问：消息是怎么划分分区的。</p>
<p>答：根据key的计算，具体的计算方法不知道。</p>
<p>问：如果key为null会怎么样。</p>
<p>答：不知</p>
<h4 id="回溯-11"><a href="#回溯-11" class="headerlink" title="回溯"></a>回溯</h4><p>1、消费者组的概念</p>
<p>2、分区和消费者组、消费者的消费关系模型</p>
<p>3、分区的指定逻辑。</p>
<p>4、key为null会怎样。</p>
<p>随机选取一个分区缓存发送，过了分区的缓存时间后在随机选取一个分区缓存发送。</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/yizhiniu_xuyw/article/details/109206709">https://blog.csdn.net/yizhiniu_xuyw/article/details/109206709</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/03/26/%E6%B7%BB%E5%8A%A0%E8%81%8A%E5%A4%A9%E5%8A%9E%E5%85%AC%E6%9C%BA%E5%99%A8%E4%BA%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="xiaozhigang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xiaozhigang">
      <meta itemprop="description" content="最后不知天在水，满船清梦压星河。">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | xiaozhigang">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/03/26/%E6%B7%BB%E5%8A%A0%E8%81%8A%E5%A4%A9%E5%8A%9E%E5%85%AC%E6%9C%BA%E5%99%A8%E4%BA%BA/" class="post-title-link" itemprop="url">添加聊天办公机器人</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2024-03-26 22:05:23 / 修改时间：23:18:50" itemprop="dateCreated datePublished" datetime="2024-03-26T22:05:23+08:00">2024-03-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/AI/" itemprop="url" rel="index"><span itemprop="name">AI</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>现在chatgpt这么火，我们也可以通过人工智能为我们的工作提供便利。</p>
<h3 id="可行性"><a href="#可行性" class="headerlink" title="可行性"></a>可行性</h3><p>1、代码开源，不需要冲头开发，基本拿来可用。</p>
<p>2、单业务领域小数据量训练的可行性，单个公司一般聚焦于一个领域业务，多领域公司可以下分到各部门。单业务领域的训练数据就会小很多，基本可以内部清洗提供。</p>
<p><img src="/../images/ChatGPT-rabbit/image-20240326225843904.png"></p>
<h3 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h3><p>1、内部服务器部署，机器人服务部署于内部服务器，保证数据安全性。</p>
<h3 id="交互性"><a href="#交互性" class="headerlink" title="交互性"></a>交互性</h3><p>1、通过开放接口和外部交互，如钉钉，微信。降低交互成本，提升交互沟通效率。</p>
<h3 id="优越性"><a href="#优越性" class="headerlink" title="优越性"></a>优越性</h3><p>1、人工智能的参与，提升员工工作效率，通过员工和人工智能沟通可以提升员工的工作效率，比如程序员可以问个代码怎么写啊类似的，不做缀叙。</p>
<p>2、部署在内部服务器的化，还可以通过其和内部任务交互，比如日常的一些小任务，可以程序化之后，部署服务器，暴露接口和人工智能交互，我们通过聊天软件通知智能机器人，让他去触发这些任务。</p>
<p><img src="/../images/ChatGPT-rabbit/image-20240326225800266.png"></p>
<p>3、降低工作量的重复，不知道大家有没有遇到过这样的情况，有时候，想请同事帮忙处理一下什么问题或这任务，同事由于有之前处理的经验或者记录，一两分钟可能就处理好了，而自己从头开始处理的话可能需要一两个小时。如果我们把这种任务程序化之后，交由机器人触发，我们需要的时候只需要以聊天的形式，通知机器人触发任务，那得多爽，这样就可以提高工作效率。</p>
<p>4、提升人工智能的准确性，从而提高员工的效率，员工在和人工智能交互的过程也是一种训练，而且还是一种监督训练，可以提供人工智能的回答准确性，从而可以提高下次和人交互的准确性。</p>
<h3 id="机会点"><a href="#机会点" class="headerlink" title="机会点"></a>机会点</h3><p>当此人工智能在单个领域训练的准确性很高的，可以考虑将此接口暴露出去，商业化，从而盈利。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/02/26/Java%E4%B8%AD%E7%9A%84%E9%94%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="xiaozhigang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xiaozhigang">
      <meta itemprop="description" content="最后不知天在水，满船清梦压星河。">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | xiaozhigang">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/02/26/Java%E4%B8%AD%E7%9A%84%E9%94%81/" class="post-title-link" itemprop="url">Java中的常用锁</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2024-02-26 20:26:53 / 修改时间：23:25:40" itemprop="dateCreated datePublished" datetime="2024-02-26T20:26:53+08:00">2024-02-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>​	在java中，我们主要用到的锁有两个：synchronized、ReentrantLock。一个是内置锁（语言级），一个是显示锁，一般如果我们不思考只图方便的话，会直接使用synchronized锁。其实ReentrantLock更灵活多变，适用更多的场景。我们可以通过下面的表对比一下两者。</p>
<table>
<thead>
<tr>
<th>特性&#x2F;维度</th>
<th><code>synchronized</code></th>
<th><code>ReentrantLock</code></th>
</tr>
</thead>
<tbody><tr>
<td>所属包</td>
<td>Java 语言层面（内置关键字）</td>
<td><code>java.util.concurrent.locks</code></td>
</tr>
<tr>
<td>可重入性</td>
<td>✅ 支持</td>
<td>✅ 支持</td>
</tr>
<tr>
<td>是否必须手动解锁</td>
<td>❌ 自动（方法或代码块退出时）</td>
<td>✅ 必须手动 <code>unlock()</code></td>
</tr>
<tr>
<td>是否可中断获取锁</td>
<td>❌ 不支持</td>
<td>✅ 支持 <code>lockInterruptibly()</code></td>
</tr>
<tr>
<td>是否支持尝试获取锁</td>
<td>❌ 不支持</td>
<td>✅ 支持 <code>tryLock()</code>（立即或超时）</td>
</tr>
<tr>
<td>是否支持公平锁</td>
<td>❌ 不支持</td>
<td>✅ 支持（<code>new ReentrantLock(true)</code>）</td>
</tr>
<tr>
<td>是否支持条件队列</td>
<td>❌ 不支持</td>
<td>✅ 支持 <code>Condition</code>（类似 <code>wait/notify</code>）</td>
</tr>
<tr>
<td>性能优化（偏向锁等）</td>
<td>✅ JVM 自动优化</td>
<td>❌ 无（完全由开发者控制）</td>
</tr>
<tr>
<td>是否支持可见调试</td>
<td>❌ 无法查看状态</td>
<td>✅ 可查看是否被锁定、等待线程等</td>
</tr>
<tr>
<td>死锁处理</td>
<td>不易发现</td>
<td>可结合 <code>tryLock()</code> 等策略避免死锁</td>
</tr>
</tbody></table>
<p>​	其实在上述这些维度方面都没啥好说的，这些一般都知道。都知道synchronized是关键字而ReentrantLock是一个类，然后两者都能加锁，这锁怎么去加，有什么效果，都是知道的。</p>
<p>​	那synchronized和ReentrantLock又分别是怎么加锁的呢？</p>
<h4 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h4><h5 id="加锁原理（底层）"><a href="#加锁原理（底层）" class="headerlink" title="加锁原理（底层）"></a>加锁原理（底层）</h5><ul>
<li>Java 对象头中包含了 <strong>Mark Word</strong>，在没有加锁时存储哈希值、GC信息等。</li>
<li>当线程进入 <code>synchronized</code> 块时，会尝试修改对象头的 Mark Word，以标识当前线程持有锁。</li>
<li>JVM 使用了多种锁优化策略（偏向锁、轻量级锁、重量级锁）：<ul>
<li><strong>偏向锁</strong>：如果只有一个线程访问，尽量不加锁，提高性能。</li>
<li><strong>轻量级锁</strong>：使用 CAS 尝试获取锁，适用于低竞争。</li>
<li><strong>重量级锁（互斥锁）</strong>：竞争激烈时，会挂起线程，使用 <code>Monitor</code> 来实现，依赖操作系统的互斥机制。</li>
</ul>
</li>
</ul>
<h5 id="加锁过程简要流程图（逻辑）"><a href="#加锁过程简要流程图（逻辑）" class="headerlink" title="加锁过程简要流程图（逻辑）"></a>加锁过程简要流程图（逻辑）</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">线程进入synchronized：</span><br><span class="line">    |</span><br><span class="line">    |-- 检查对象头Mark Word（是否偏向、锁状态）</span><br><span class="line">        |</span><br><span class="line">        |-- 如果空闲，则尝试通过CAS加锁（轻量级）</span><br><span class="line">        |</span><br><span class="line">        |-- 如果失败，有竞争，则升级为重量级锁（挂起线程）</span><br></pre></td></tr></table></figure>



<h5 id="字节码层面"><a href="#字节码层面" class="headerlink" title="字节码层面"></a>字节码层面</h5><p>编译后使用 <code>javap -v Test.class</code> 查看，会看到如下结构：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">syncBlock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>反编译字节码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">asm</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CopyEdit</span><br><span class="line">0: aload_0</span><br><span class="line">1: dup</span><br><span class="line">2: monitorenter       // 进入同步块</span><br><span class="line">3: getstatic java/lang/System.out : Ljava/io/PrintStream;</span><br><span class="line">6: ldc &quot;Hello&quot;</span><br><span class="line">8: invokevirtual java/io/PrintStream.println(Ljava/lang/String;)V</span><br><span class="line">11: monitorexit       // 退出同步块</span><br><span class="line">12: goto 20</span><br><span class="line">15: astore_1</span><br><span class="line">16: monitorexit       // 异常时也要退出同步块</span><br><span class="line">17: aload_1</span><br><span class="line">18: athrow</span><br></pre></td></tr></table></figure>

<p><code>monitorenter</code> 和 <code>monitorexit</code> 是 JVM 指令，由 JVM 解释器直接处理，底层是调用 native 方法去操作对象的 Monitor。</p>
<h5 id="JVM实现细节"><a href="#JVM实现细节" class="headerlink" title="JVM实现细节"></a>JVM实现细节</h5><p>HotSpot 中，对象的 Monitor 实际上是 <code>ObjectMonitor</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ObjectMonitor</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  ObjectWaiter * _EntryList;   <span class="comment">// 等待锁的线程队列</span></span><br><span class="line">  Thread * _Owner;             <span class="comment">// 当前持有锁的线程</span></span><br><span class="line">  <span class="type">int</span> _recursions;             <span class="comment">// 重入次数</span></span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Monitor 与每个对象的 <strong>对象头（Mark Word）</strong> 关联，当竞争严重时锁会升级：</p>
<ul>
<li><strong>偏向锁</strong>：只记录线程 ID，适合无竞争场景</li>
<li><strong>轻量级锁</strong>：线程通过 CAS 抢占锁</li>
<li><strong>重量级锁</strong>：膨胀为 <code>ObjectMonitor</code>，线程挂起和唤醒都依赖 OS 的 <code>park/unpark</code></li>
</ul>
<h4 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h4><h5 id="加锁原理（底层）-1"><a href="#加锁原理（底层）-1" class="headerlink" title="加锁原理（底层）"></a>加锁原理（底层）</h5><ul>
<li><code>ReentrantLock</code> 是基于 <strong>AQS（AbstractQueuedSynchronizer）</strong> 实现的。</li>
<li>调用 <code>lock()</code> 会尝试通过 CAS 修改一个 <strong>state 状态变量</strong>，来标识是否持有锁。</li>
<li>若获取失败，线程会被放入 AQS 的 <strong>双向等待队列</strong>中，等待唤醒。</li>
</ul>
<h5 id="加锁过程简要流程图（逻辑）-1"><a href="#加锁过程简要流程图（逻辑）-1" class="headerlink" title="加锁过程简要流程图（逻辑）"></a>加锁过程简要流程图（逻辑）</h5><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">线程调用lock()：</span><br><span class="line">    |</span><br><span class="line">    |<span class="comment">-- 尝试通过CAS将state从0改为1（加锁）</span></span><br><span class="line">        |</span><br><span class="line">        |<span class="comment">-- 如果成功，获得锁</span></span><br><span class="line">        |</span><br><span class="line">        |<span class="comment">-- 如果失败，进入AQS等待队列</span></span><br></pre></td></tr></table></figure>



<h5 id="AQS的队列结构"><a href="#AQS的队列结构" class="headerlink" title="AQS的队列结构"></a>AQS的队列结构</h5><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">head -&gt; [Node1] -&gt; [Node2] -&gt; ...</span><br><span class="line">         <span class="built_in">^</span>          <span class="built_in">^</span></span><br><span class="line">      线程1     线程2（阻塞）</span><br></pre></td></tr></table></figure>

<p>每个 Node 包含：</p>
<ul>
<li>等待线程 <code>Thread thread</code></li>
<li>等待状态 <code>waitStatus</code></li>
<li>前驱&#x2F;后继节点 <code>prev</code> &#x2F; <code>next</code></li>
</ul>
<p>底层通过 <code>LockSupport.park()</code> 和 <code>unpark()</code> 来实现线程的阻塞与唤醒。</p>
<h4 id="如何唤醒"><a href="#如何唤醒" class="headerlink" title="如何唤醒"></a>如何唤醒</h4><p>​	两者都是有阻塞队列，队列都是有序的，为什么会出现非公平唤醒呢？</p>
<p>​	**因为”排队” ≠ “唤醒一定按顺序”**。</p>
<p>Java 的锁（尤其是默认的 <code>synchronized</code> 和非公平 <code>ReentrantLock</code>）使用的阻塞队列只是<strong>阻塞等待顺序的组织方式</strong>，但<strong>唤醒后是否真正获得锁，还要竞争</strong>（CAS），所以就可能出现：</p>
<blockquote>
<p><strong>先排队的线程被唤醒了，但还没抢到锁；此时一个新线程进来，直接CAS成功拿到了锁。</strong></p>
</blockquote>
<h3 id="1-synchronized-的非公平行为"><a href="#1-synchronized-的非公平行为" class="headerlink" title="1. synchronized 的非公平行为"></a>1. <code>synchronized</code> 的非公平行为</h3><p><code>synchronized</code> 底层用的是 <code>ObjectMonitor</code>，当有多个线程竞争时，JVM 不保证 <strong>先唤醒的一定先拿到锁</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ObjectMonitor.cpp</span></span><br><span class="line"><span class="keyword">void</span> ObjectMonitor::exit(...) &#123;</span><br><span class="line">    <span class="comment">// 调用 _EntryList 中的某个线程 unpark（但可能不是严格FIFO）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>唤醒后还要重新尝试获取锁（CAS）</strong>，不是直接转移锁的拥有权，所以：</p>
<ul>
<li><p>后来的线程进来，如果没有阻塞，仍然可能直接成功拿到锁。</p>
</li>
<li><p>被唤醒的线程，反而还得和新线程竞争，可能继续失败。</p>
</li>
</ul>
<h3 id="2-ReentrantLock-的非公平行为"><a href="#2-ReentrantLock-的非公平行为" class="headerlink" title="2. ReentrantLock 的非公平行为"></a>2. <code>ReentrantLock</code> 的非公平行为</h3><p>默认构造的 <code>ReentrantLock()</code> 是<strong>非公平锁</strong>，非公平策略体现在 <code>lock()</code> 方法中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;     <span class="comment">// 直接抢锁，不管队列中有没有人</span></span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        acquire(<span class="number">1</span>);                     <span class="comment">// 抢不到才排队</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是说：</p>
<ul>
<li><strong>没有优先检查 AQS 队列中是否有等待的线程</strong></li>
<li>只要锁是空闲的，谁来谁抢，先到的不一定先拿到</li>
</ul>
<p>即使队列中有等待线程，新线程仍然可以“插队”成功。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/02/26/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="xiaozhigang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xiaozhigang">
      <meta itemprop="description" content="最后不知天在水，满船清梦压星河。">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | xiaozhigang">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/02/26/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" class="post-title-link" itemprop="url">深度学习</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2024-02-26 20:26:53 / 修改时间：23:25:40" itemprop="dateCreated datePublished" datetime="2024-02-26T20:26:53+08:00">2024-02-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/AI/" itemprop="url" rel="index"><span itemprop="name">AI</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>​	在大模型大行其道的今天，学习使用大模型已经是我们程序猿不可或缺的一部分。网传的大模型神乎其神，貌似无所不能，那么大模型的底层到底是什么，是怎么一步一步的发展到今天的大模型的呢。其实大模型的底层本质就是深度学习，只不是跟我们了解的深度学习不一样的是大模型的参数比较多，甚至可以说多的可怕。了解完深度学习之后你就知道为什么参数可以作为大模型的一个指标了。</p>
<p>​	其实深度学习大致可以划分成三步：构建函数模型、计算缺失值、优化。</p>
<h2 id="案例背景"><a href="#案例背景" class="headerlink" title="案例背景"></a>案例背景</h2><p>​	已知店铺A，11月份每一天的每一天的营业额，我们怎么计算预测12月前3天的营业额。</p>
<p><img src="/Users/xiaozhigang/blog/source/images/deep-learning/image-20241230182713456.png" alt="image-20241230182713456"></p>
<h2 id="简单模型预测"><a href="#简单模型预测" class="headerlink" title="简单模型预测"></a>简单模型预测</h2><p>​	按照我们上述说的三个步骤，将整个过程划分成三步，构建函数模型，计算缺失值，计算参数。</p>
<h3 id="构建函数模型"><a href="#构建函数模型" class="headerlink" title="构建函数模型"></a>构建函数模型</h3><p>​	这里我们先构建一个简单的预测模型，其实预测模型就是一个关系函数，就是被预测的结果和前面输入之间的关系函数，在这里就是12月前3天的营业额和11月营业额之间的关系。关系函数我们表示为 y&#x3D;f(x)，在这里我们先构建一个最简单的预测模型，假设后一天的营业额和前一天的营业额之间的关系函数是 y&#x3D;ax+b，y是后一天我们预测的营业额，x是当日的营业额。</p>
<h3 id="计算缺失值"><a href="#计算缺失值" class="headerlink" title="计算缺失值"></a>计算缺失值</h3><p>​	现在我们知道了营业额之间的预测函数和11月整个月的营业额，这样我们就可以计算出整个11月真是营业额和我们预测函数计算出来的预测营业额之间的差值L。<br>$$<br>L&#x3D;\frac{1}{N} \Sigma(|y- \hat{y}|)<br>$$<br>​	上面的公式，就是11月的预测值和实际值的差值求平均值。如果我们随机选取一个较小的a、b的初始值，就能计算出缺失值L的值，当我们不停的变幻a、b值之后，就会得到不同的L值。不同的a、b值和L可以构建出下图这样一个统计图，其中蓝色区域是L的较小值，红色是交大值。</p>
<p><img src="/Users/xiaozhigang/blog/source/images/deep-learning/image-20250102085812272.png" alt="image-20250102085812272"></p>
<h3 id="计算参数"><a href="#计算参数" class="headerlink" title="计算参数"></a>计算参数</h3><p>​	根据公式，我们是能算出缺失值L的，但是由于我们的预测模型是 y&#x3D;ax+b，那么我们的缺失值的结果这也一定包含着这两个参数，换而言之就是这两个参数影响着我们的计算结果缺失值L。实际情况中，我们总是希望误差越小越好，也就是缺失值L越小越好。</p>
<p>​	在数学中，我们求最小值，一般都和斜率相关，找到L的斜率等于0的值，我们应该就能找到一个合适a、b值。我们将L对a、b求偏导，就能找到L相对小的点。这样也就得出了合适的a、b值，从而得到了一个合适的预测函数y&#x3D;ax+b。</p>
<p><img src="/Users/xiaozhigang/blog/source/images/deep-learning/image-20250102090855503.png" alt="image-20250102090855503"></p>
<h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>​	上面我们只是选了一个最简单的折线模型去计算预测值，折线模型只是最简单的模型，在本质上就有所不足，不能很好的预测多参数曲线值。如下图，如果我们用折线模型去模拟计算那条红色的折线，就不是很好计算模拟。如果我们多加几个参数，就比较好计算模拟了。</p>
<p>​	可以使用sigmoid(x)的函数(下图蓝色折线1)，多几个参数模拟出红色折线。蓝色折线0、1、2、3相加就等于红色折线，折线0是一个常数a，折线2是 c<em>sigmoid(x+b)，折线3是d</em>sigmoid(x+e)。从而得出：*</p>
<p><em>y&#x3D;sigmoid(x) + a + c</em>sigmoid(x+b) + d*sigmoid(x+e)</p>
<p>$$<br>y&#x3D;b+\sum_iC_i*sigmoid(b_i+w_ix)<br>$$<br>同时我们可以看到，销售额呈周期性变化。我们可以通过一个周期内销售额去计算预测值，公式如下。<br>$$<br>y&#x3D;b+\sum_ic_isigmoid(b_i+\sum_jw_{ij}x_j)<br>$$</p>
<p><img src="/Users/xiaozhigang/blog/source/images/deep-learning/image-20250102180023235.png" alt="image-20250102180023235"></p>
<p>​	我们根据上面的公式可以计算出预测值，上述的公式5得出，如果我们计算出在得知前三个销售额的情况下，预测出的销售额。</p>
<p><img src="/Users/xiaozhigang/blog/source/images/deep-learning/image-20250112154212786.png" alt="image-20250112154212786"></p>
<p>​	上面的演示结果可以得出<br>$$<br>y &#x3D; b + \sum_i c_i sigmoid(r_i)<br>$$<br>​	如果我们将 sigmoid(r) 看出一个整体的话，可以简化成<br>$$<br>y &#x3D; b + c^T<em>a<br>$$<br>​	整个公式：<br>$$<br>y&#x3D;b+c^T</em>a &#x3D; b+c^T * \sigma(b+wx)<br>$$<br>​	注意上面的两个b不是同一个值。</p>
<p>​	整个计算逻辑，如图展示：</p>
<p><img src="/Users/xiaozhigang/blog/source/images/deep-learning/image-20250112164453491.png" alt="image-20250112164453491"></p>
<p>​	上面的计算模型只是模拟计算了一层，我们可以模拟计算多层，深度学习的本质就是让我们模拟计算跟多的层次以达到更好的效果，如果我们模拟计算两层的话，可以将我们第一层计算出来的a，再来一次计算。</p>
<p><img src="/Users/xiaozhigang/blog/source/images/deep-learning/image-20250112165402027.png" alt="image-20250112165402027">总结</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​	整个深度学习的过程就是推导出一个合适的计算模型。推导模型的过程可以分为三步：<strong>构建函数模型，计算缺失值，计算参数</strong>。在后面的优化过程中，我们总共优化了三个点：</p>
<p>1、模型替换，更换成了一个更有弹性的模型</p>
<p>2、增加模型输入，以上述销售额为例，从前一天的销售额预测后一天的销售额变成前几天的销售额预测后一天</p>
<p>3、增加训练层数，将一层计算变成多层计算</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/02/16/%E6%B5%85%E8%B0%88ChatGPT/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="xiaozhigang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xiaozhigang">
      <meta itemprop="description" content="最后不知天在水，满船清梦压星河。">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | xiaozhigang">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/02/16/%E6%B5%85%E8%B0%88ChatGPT/" class="post-title-link" itemprop="url">浅谈ChatGPT</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-02-16 20:26:53" itemprop="dateCreated datePublished" datetime="2024-02-16T20:26:53+08:00">2024-02-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-02-26 23:25:40" itemprop="dateModified" datetime="2024-02-26T23:25:40+08:00">2024-02-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/AI/" itemprop="url" rel="index"><span itemprop="name">AI</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>下面谈一谈我对chatGPT的简单认知，这也是看了许多资料总结出来的，没有去实际去研究chatGPT的代码，我姑且言之，有兴趣的同学姑且听之。</p>
<p>去年chatGPT大火，才让我们对人工智能有了更深一步的了解。之前认为的智能聊天就是像那些客服机器人一样，反反复复就那么几句话，跟智障一样，现在看到chatGPT这么厉害，宛若神明。</p>
<h2 id="归根到底的数学概率"><a href="#归根到底的数学概率" class="headerlink" title="归根到底的数学概率"></a>归根到底的数学概率</h2><p>​        其实大家可以简单理解，chatGPT的语言生成是一个数学概率模型，他的一个词语到生成下一个词语是采用概率最大的词语生成，就比如说，你输入一堆数据提供chatGPT训练，其中词语A后面接词语B的次数最多也就是概率最大，那么下次chatGPT给你生成回复的时候词语A后面接词语B的概率也最大。当然这也是简单说，实际肯定没这么简单。如下图，<strong>伟大的国家</strong> 这个概率是99%，拎一个选项是1%。那自然会生成 <strong>中国是个伟大的国家</strong> 。</p>
<p><img src="/../images/ai-chatgpt/ea478ffa1e61f12af5ebc8d25602f919.webp" alt="img"></p>
<h2 id="语言模型的两个方向"><a href="#语言模型的两个方向" class="headerlink" title="语言模型的两个方向"></a>语言模型的两个方向</h2><p>​       其实在语言模型这块一直有两个方向，一个是语义理解，一个是语句生成。语义理解是谷歌主要研究的方向，这个类似于完形填空。而语句生成是0penAI的主要方向，也就是我们现在看到的chatGPT，这个类似于写作文。这两种的应用环境和使用的算法也是不一样的，简单的说一下，语义理解，是根据前后文，两个维度计算出中间的缺失，谷歌已经做到了很高的准确率，这就对我们英语考试中的完形填空很友好了。而语句生成就跟我们写作文一样，从头写到尾，只有一个维度支撑。这就是谷歌Bert和openAI的ChatGPT的差别，双向和自回归。</p>
<p><img src="/../images/ai-chatgpt/6254574f3a2cc5105494612a0dfad723.webp" alt="img"></p>
<h2 id="数学-技术"><a href="#数学-技术" class="headerlink" title="数学+技术"></a>数学+技术</h2><p>​        Bert和ChatGPT都是基于Transformer实现的，啥是Transformer呢，简单理解就是我们上面说的根据概率最大生成文字。只不过这生成的实现很复杂，大概说-下，我们输入的句子会被拆分成一个一个的单词(token),根据这些单词计算向量权重，最后根据这些解析拆分后的向量权重计算概率生成输出。这些向量是怎么计算的呢，我们看个例子，国王-男人+女人&#x3D;女王，这种向量的计算是不是很有意思。</p>
<p><img src="/../images/ai-chatgpt/66a2a20fa52ed120f7e5c9658a352120.webp" alt="img"></p>
<h2 id="监督学习"><a href="#监督学习" class="headerlink" title="监督学习"></a>监督学习</h2><p>​        当然上面的过程也只是其中的训练的一环，还有重要的监督学习。ChatGPT根据概率输出的东西很难保证准确性，毕竟是没有思想的机器，所以这时候就需要我们监督学习，给他的输出打分，正确的分数就高，错误的分数就低，这要提高了正确回答的权重，也就影响了概率和输出。</p>
<p><img src="/../images/ai-chatgpt/795e4d0244dabc76f1cbae17e5eff242.webp" alt="img"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​        网上好多资料说了一大堆高大尚的名词:深度学习、循环神经网络、自然语言处理技术、注意力机制、损失函数。这些都是具体实现，不做ai 的也没必要深入了解，知道chatGPT的大概原理也就够了。目前好多人说chatGPT的出现会对现在的社会造成巨大的冲击，绝大多数人都会失业。我想说这并不一定，上面也说了人工智能是根据概率推算结果的，这个概率是根据已有事件计算的，类似于绝大多数人说啥，他也会说啥。这也就是说，他是没有创造力的，他只能帮我们整理已有事件，不会突破已有的事件。比如说当绝大多数人都认为地球是-个平面的时候，chatGPT也会认为地球是一个平面，不会有思考发现地球是个球体。人工智能只是解放了我们生产力，让我们有更多的时间去完成一些创造性的事情。但是如果我们一直在做这种重复性的事情，没有思考创新，chatGPT的出现对我们来说绝对会是个巨大的灾难，至少摸鱼的机会会大大减少。</p>
<p><img src="/../images/ai-chatgpt/eba3e800c5d91f0bd18bab2a2ac41e54.webp" alt="img"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/11/13/kafka%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E4%B8%8D%E4%B8%A2%E5%A4%B1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="xiaozhigang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xiaozhigang">
      <meta itemprop="description" content="最后不知天在水，满船清梦压星河。">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | xiaozhigang">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/11/13/kafka%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E4%B8%8D%E4%B8%A2%E5%A4%B1/" class="post-title-link" itemprop="url">kafka保证消息不丢失</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-11-13 21:23:57" itemprop="dateCreated datePublished" datetime="2023-11-13T21:23:57+08:00">2023-11-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/" itemprop="url" rel="index"><span itemprop="name">中间件</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h3><p>在kafka的使用过程中，消息传递有下图三个步骤，消息的丢失也就在这三个步骤中：发送过程中丢失、同步过程中丢失、拉取过程中丢失。</p>
<p><img src="/../images/kafka/image-20240331213103843.png" alt="image-20240331213103843"></p>
<h3 id="发送过程中丢失"><a href="#发送过程中丢失" class="headerlink" title="发送过程中丢失"></a>发送过程中丢失</h3><h4 id="发送方式"><a href="#发送方式" class="headerlink" title="发送方式"></a>发送方式</h4><p>生产者的发送方式有三种：</p>
<p>1、简单发送，不关心发送结果，所以发送失败消息丢失也不知道。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ProducerRecord&lt;String,String&gt; record = <span class="keyword">new</span> <span class="title class_">ProducerRecord</span>&lt;&gt;(<span class="string">&quot;topicName&quot;</span>,<span class="string">&quot;key&quot;</span>,<span class="string">&quot;value&quot;</span>);</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">   <span class="comment">//这里只是把消息放进了一个缓冲区中，然后使用单独的线程将消息发送到服务端</span></span><br><span class="line">   producer.send(record);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(Exception)&#123;</span><br><span class="line">   e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、同步发送，等待发送返回</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ProducerRecord&lt;String,String&gt; record = <span class="keyword">new</span> <span class="title class_">ProducerRecord</span>&lt;&gt;(<span class="string">&quot;topicName&quot;</span>,<span class="string">&quot;key&quot;</span>,<span class="string">&quot;value&quot;</span>);</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">   <span class="comment">//send方法返回的是Future&lt;RecordMetaData&gt; 对象，然后我们可以调用get()方法等待响应</span></span><br><span class="line">   Future&lt;RecordMetaData&gt; future = producer.send(record); </span><br><span class="line">   future.get();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(Exception)&#123;</span><br><span class="line">   e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、异步发送，执行回调方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">DemoProducerCallback</span> <span class="keyword">implements</span> <span class="title class_">Callback</span>&#123;</span><br><span class="line">   <span class="meta">@override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCompletion</span><span class="params">(RecordMetadata recordMetadata,Exception e)</span>&#123;</span><br><span class="line">       <span class="comment">//发生错误的回调方法,可以写入日志，或写入DB通过其它线程重重试，保证最终的数据送达</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">ProducerRecord&lt;String,String&gt; record = <span class="keyword">new</span> <span class="title class_">ProducerRecord</span>&lt;&gt;(<span class="string">&quot;topicName&quot;</span>,<span class="string">&quot;key&quot;</span>,<span class="string">&quot;value&quot;</span>);</span><br><span class="line">producer.send(record，<span class="keyword">new</span> <span class="title class_">DemoProducerCallback</span>()))</span><br></pre></td></tr></table></figure>

<p>在这三种发送方法中，第一种方法，无返回，不感知，所以也无法保证消息不丢失。所以要保证消息不丢失，只能选择第二种或者第三种，一般情况下更推荐第三种。</p>
<h4 id="acks参数设置"><a href="#acks参数设置" class="headerlink" title="acks参数设置"></a>acks参数设置</h4><p>在生产者中有acks参数，该参数指定了kafka的多少个副本同步后才算消息发送成功。该参数取值范围：</p>
<p>1、acks&#x3D;0，表示生产者在消息后不管有没有在leader磁盘上落盘，就认为消息发送成功。</p>
<p>2、acks&#x3D;1，表示生产者在消息后，在leader磁盘上落盘，就认为消息发送成功，不管其他follower有没有同步。</p>
<p>3、acks&#x3D;all，表示生产者在消息后，在leader磁盘上落盘，其他follower都同步落盘， 认为消息发送成功。</p>
<p><img src="/../images/kafka/image-20240331222238322.png" alt="image-20240331222238322"></p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>通过设置发送方式和acks参数，可以保证在发送方式中不丢失，甚至acks参数都可以保证后面的同步过程中消息不丢失。</p>
<p>发送方式一般设置为异步发送，acks参数默认设置为1。</p>
<h3 id="同步过程中丢失"><a href="#同步过程中丢失" class="headerlink" title="同步过程中丢失"></a>同步过程中丢失</h3><p>在同步过程中，除了上面说的答acks参数，还有其他副本机制保证消息不丢失。避免leader节点的崩溃导致消息的丢失。</p>
<p>broker中的配置项,unclean.leader.election.enable &#x3D; false，表示不允许非ISR中的副本被选举为首领，以免数据丢失。</p>
<p>ISR：是指与leader保持一定程度（这种范围是可通过参数进行配置的）同步的副本和 leader 共同被称为ISR</p>
<p>OSR：与leader同步时，滞后很多的副本（不包括leader）被称为OSR</p>
<p>AR，分区中所有的副本统称为AR。AR &#x3D; ISR + OSR</p>
<h3 id="拉取过程中丢失"><a href="#拉取过程中丢失" class="headerlink" title="拉取过程中丢失"></a>拉取过程中丢失</h3><p>设置 enable.auto.commit &#x3D; false，在consumer端消费消息操作完成以后再手动提交 offset，类似于下文中的代码示例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">consumerMsg</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="comment">//这里的poll(100)指的是kafka server端没有消息时，连接等待的时间，超过该时间立即返回空给consumer</span></span><br><span class="line">        ConsumerRecords&lt;String,String&gt; records = consomer.poll(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">for</span>(ConsumerRecord&lt;String,String&gt; record : records)&#123;</span><br><span class="line">            <span class="comment">// 这里是消费消息的逻辑（简单逻辑输入到控制台）</span></span><br><span class="line">            System.out.printIn(record.value));</span><br><span class="line">            <span class="comment">//提交偏移量</span></span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                consumer.commitSync();  <span class="comment">//同步提交 如果异步的话，可以使用 consumer.commitAsync();</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span>(CommitFailedException ex)&#123;</span><br><span class="line">                log.error(<span class="string">&quot;commit fail&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 2022 – 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">xiaozhigang</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>


    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>


  <script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"default","dark":"dark"},"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mermaid/10.7.0/mermaid.min.js","integrity":"sha256-TtLOdUA8mstPoO6sGvHIGx2ceXrrX4KgIItO06XOn8A="}}</script>
  <script src="/js/third-party/tags/mermaid.js"></script>





  





</body>
</html>
